var __defProp=Object.defineProperty;var __export=(target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:true})};var DataStructures_exports={};__export(DataStructures_exports,{AuthorizationStruct:()=>AuthorizationStruct,ChatroomStruct:()=>ChatroomStruct,CoherenceMap:()=>CoherenceMap,CoherenceStruct:()=>CoherenceStruct,CommentStruct:()=>CommentStruct,Data:()=>Data,DataStruct:()=>DataStruct,DateStruct:()=>DateStruct,ECGStruct:()=>ECGStruct,EDAStruct:()=>EDAStruct,EEGCoordinates:()=>EEGCoordinates,EEGStruct:()=>EEGStruct,EMGStruct:()=>EMGStruct,EventStruct:()=>EventStruct,EyeTrackerStruct:()=>EyeTrackerStruct,FNIRSStruct:()=>FNIRSStruct,FrequencyBandsStruct:()=>FrequencyBandsStruct,GroupStruct:()=>GroupStruct,HRVStruct:()=>HRVStruct,IMUStruct:()=>IMUStruct,NotificationStruct:()=>NotificationStruct,PPGStruct:()=>PPGStruct,ProfileStruct:()=>ProfileStruct,ScheduleStruct:()=>ScheduleStruct,Struct:()=>Struct,eegCoordinates:()=>eegCoordinates,setCoordinate:()=>setCoordinate,structRegistry:()=>structRegistry});function Struct(structType="struct",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){function randomId3(tag=""){return`${tag+Math.floor(Math.random()+Math.random()*Math.random()*1e16)}`}let struct={_id:randomId3(structType+"defaultId"),structType,ownerId:parentUser?._id,timestamp:Date.now(),parent:{structType:parentStruct?.structType,_id:parentStruct?._id}};if(!struct.ownerId)delete struct.ownerId;if(!struct?.parent?._id)delete struct.parent;if(Object.keys(assignProps).length>0)Object.assign(struct,assignProps);return struct}var eegCoordinates={FP1:[-21.2,66.9,12.1],FPZ:[1.4,65.1,11.3],FP2:[24.3,66.3,12.5],AF7:[-41.7,52.8,11.3],AF3:[-32.7,48.4,32.8],AFZ:[1.8,54.8,37.9],AF4:[35.1,50.1,31.1],AF8:[43.9,52.7,9.3],F5:[-51.4,26.7,24.7],F3:[-39.7,25.3,44.7],F1:[-22.1,26.8,54.9],FZ:[0,26.8,60.6],F2:[23.6,28.2,55.6],F4:[41.9,27.5,43.9],F6:[52.9,28.7,25.2],F7:[-52.1,28.6,3.8],F8:[53.2,28.4,3.1],FC5:[-59.1,3,26.1],FC3:[-45.5,2.4,51.3],FC1:[-24.7,.3,66.4],FCZ:[1,1,72.8],FC2:[26.1,3.2,66],FC4:[47.5,4.6,49.7],FC6:[60.5,4.9,25.5],FT9:[-53.8,-2.1,-29.1],FT7:[-59.2,3.4,-2.1],FT8:[60.2,4.7,-2.8],FT10:[55,-3.6,-31],T7:[-65.8,-17.8,-2.9],T5:[-61.5,-65.3,1.1],T3:[-70.2,-21.3,-10.7],T4:[71.9,-25.2,-8.2],T6:[59.3,-67.6,3.8],T8:[67.4,-18.5,-3.4],C5:[-63.6,-18.9,25.8],C3:[-49.1,-20.7,53.2],C1:[-25.1,-22.5,70.1],CZ:[.8,-21.9,77.4],C2:[26.7,-20.9,69.5],C4:[50.3,-18.8,53],C6:[65.2,-18,26.4],CP5:[-61.8,-46.2,22.5],CP3:[-46.9,-47.7,49.7],CP1:[-24,-49.1,66.1],CPZ:[.7,-47.9,72.6],CP2:[25.8,-47.1,66],CP4:[49.5,-45.5,50.7],CP6:[62.9,-44.6,24.4],TP9:[-73.6,-46.7,-4],TP7:[-63.6,-44.7,-4],TP8:[64.6,-45.4,-3.7],TP10:[74.6,-47.4,-3.7],P9:[-50.8,-51.3,-37.7],P7:[-55.9,-64.8,0],P5:[-52.7,-67.1,19.9],P3:[-41.4,-67.8,42.4],P1:[-21.6,-71.3,52.6],PZ:[.7,-69.3,56.9],P2:[24.4,-69.9,53.5],P4:[44.2,-65.8,42.7],P6:[54.4,-65.3,20.2],P8:[56.4,-64.4,.1],P10:[51,-53.9,-36.5],PO7:[-44,-81.7,1.6],PO3:[-33.3,-84.3,26.5],POZ:[0,-87.9,33.5],PO4:[35.2,-82.6,26.1],PO8:[43.3,-82,.7],O1:[-25.8,-93.3,7.7],OZ:[.3,-97.1,8.7],O2:[25,-95.2,6.2]};function setCoordinate(channelDict,assignTo={}){if(!eegCoordinates[channelDict.tag]&&channelDict.position){eegCoordinates[channelDict.tag]=[channelDict.position.x,channelDict.position.y,channelDict.position.z]}if(eegCoordinates[channelDict.tag]){let props={channel:"",position:{x:eegCoordinates[channelDict.tag][0],y:eegCoordinates[channelDict.tag][1],z:eegCoordinates[channelDict.tag][2]}};return Object.assign(assignTo,props)}else return Object.assign(assignTo,channelDict)}function EEGCoordinates(channelDicts=[],genCoherenceMap=true){let structs=[];for(let channelDict of channelDicts){let struct=EEGStruct(channelDict);structs.push(struct)}if(genCoherenceMap){structs.push(...CoherenceMap({channelDicts}))}return structs}function FrequencyBandsStruct(additionalBands=[],assignTo={}){let bands={scp:[],delta:[],theta:[],alpha1:[],alpha2:[],beta:[],lowgamma:[],highgamma:[]};additionalBands.forEach(band=>bands[band]=[]);return Object.assign(assignTo,bands)}function EEGStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let bands=FrequencyBandsStruct();let props={tag,position:{x:0,y:0,z:0},count:0,times:[],raw:[],filtered:[],fftCount:0,fftTimes:[],ffts:[],slices:JSON.parse(JSON.stringify(bands)),means:JSON.parse(JSON.stringify(bands)),startTime:Date.now()};let struct=Struct("eeg",props,parentUser,parentStruct);if(tag)setCoordinate(props,struct);return Object.assign(struct,assignProps)}function CoherenceStruct(coords={0:EEGStruct("FP1"),1:EEGStruct("FP2")},assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let bands=FrequencyBandsStruct();let props={tag:coords[0]?.tag+"::"+coords[1]?.tag,x0:coords[0]?.position?.x,y0:coords[0]?.position?.y,z0:coords[0]?.position?.z,x1:coords[1]?.position?.x,y1:coords[1]?.position?.y,z1:coords[1]?.position?.z,fftCount:0,fftTimes:[],ffts:[],slices:JSON.parse(JSON.stringify(bands)),means:JSON.parse(JSON.stringify(bands)),startTime:Date.now()};let struct=Struct("coherence",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function CoherenceMap(opts={channelDicts:[{ch:0,tag:"FP1",analyze:false},{ch:1,tag:"FP2",analyze:false}],taggedOnly:true},_={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){var cmap=[];var l=1,k2=0;for(var i3=0;i3<opts.channelDicts.length*(opts.channelDicts.length+1)/2-opts.channelDicts.length;i3++){if(opts.taggedOnly===false||opts.taggedOnly===true&&(opts.channelDicts[k2].tag!==null&&opts.channelDicts[k2+l].tag!==null&&(opts.channelDicts[k2].tag!=="other"&&opts.channelDicts[k2+l].tag!=="other")&&(opts.channelDicts[k2].analyze===true&&opts.channelDicts[k2+l].analyze===true))){var coord0=EEGStruct(opts.channelDicts[k2].tag);var coord1=EEGStruct(opts.channelDicts[k2+l].tag);cmap.push(CoherenceStruct({0:coord0,1:coord1},{},parentUser,parentStruct))}l++;if(l+k2===opts.channelDicts.length){k2++;l=1}}return cmap}function FNIRSStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,position:{x:0,y:0,z:0},count:0,times:[],red:[],ir:[],ir2:[],ambient:[],ratio:[],temp:[],beat_detect:{beats:[],breaths:[],rir:[],rir2:[],drir_dt:[],localmins:[],localmaxs:[],val_dists:[],peak_dists:[],localmins2:[],localmaxs2:[],val_dists2:[],peak_dists2:[]},startTime:Date.now()};let struct=Struct("fnirs",props,parentUser,parentStruct);if(tag)setCoordinate(props,struct);return Object.assign(struct,assignProps)}function IMUStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,Ax:[],Ay:[],Az:[],Gx:[],Gy:[],Gz:[],startTime:Date.now()};let struct=Struct("imu",props,parentUser,parentStruct);if(tag)setCoordinate(props,struct);return Object.assign(struct,assignProps)}function EyeTrackerStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,count:0,times:[],x:[],y:[],smax:[],smay:[],startTime:Date.now()};let struct=Struct("eyetracker",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function ECGStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,count:0,times:[],raw:[],filtered:[],bpm:[],hrv:[],startTime:Date.now()};let struct=Struct("ecg",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function EDAStruct(_="",__={},___={_id:""},____={structType:"struct",_id:""}){}function PPGStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let struct=FNIRSStruct(tag,parentUser,parentStruct,assignProps);struct.structType="ppg";return struct}function HRVStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let struct=ECGStruct(tag,parentUser,parentStruct,assignProps);struct.structType="hrv";return struct}function EMGStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let struct=EEGStruct(tag,parentUser,parentStruct,assignProps);struct.structType="emg";return struct}function ProfileStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,name:"",username:"",firstName:"",lastName:"",email:"",phone:"",sex:"",birthday:"",type:"",pictureUrl:"",userRoles:{},socials:{},data:{},hidden:false,accessToken:"",refreshToken:""};let struct=Struct("profile",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function AuthorizationStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,authorizedId:"",authorizedName:"",authorizerId:"",authorizerName:"",authorizations:{},structs:{},excluded:{},groups:{},status:"PENDING",expires:false,associatedAuthId:""};let struct=Struct("authorization",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function GroupStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,name:"",details:"",admins:{},peers:{},clients:{},users:{}};let struct=Struct("group",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function Data(type,data){return{type,data,timestamp:Date.now()}}function DataStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,title:"",author:"",expires:false,type:"",data:new Array};let struct=Struct("data",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function EventStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,event:"",author:"",startTime:"",endTime:"",grade:void 0,value:void 0,units:void 0,location:void 0,notes:"",attachments:new Array,users:{}};let struct=Struct("event",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function ChatroomStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,message:"",topic:"",author:"",attachments:new Array,comments:new Array,replies:new Array,users:{},audioChatActive:false,videoChatActive:false};let struct=Struct("chatroom",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function CommentStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,author:"",replyTo:"",message:"",rating:0,replies:new Array,users:{},attachments:new Array};let struct=Struct("comment",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function NotificationStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,note:"",parentUserId:""};let struct=Struct("notification",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function ScheduleStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,title:"",author:"",attachments:new Array,dates:new Array};let struct=Struct("schedule",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function DateStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,timeSet:"",notes:"",recurs:"NEVER",attachments:new Array};let struct=Struct("date",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}var structRegistry={Struct,EEGStruct,FNIRSStruct,CoherenceStruct,CoherenceMap,FrequencyBandsStruct,IMUStruct,EyeTrackerStruct,ECGStruct,EDAStruct,PPGStruct,HRVStruct,EMGStruct,ProfileStruct,AuthorizationStruct,GroupStruct,DataStruct,EventStruct,ChatroomStruct,CommentStruct,NotificationStruct,ScheduleStruct,DateStruct};var DataTablet=class{id;threaded;workers;DS=DataStructures_exports;collections=new Map;data={byTime:{},notes:{},events:{},sleep:{},food:{},rx:{},hr:{},ppg:{},hrv:{},ecg:{},emg:{},eeg:{},fnirs:{}};rolloverLimit=5e4;dataSorts=new Map;watches={};constructor(props={}){Object.assign(this.data,props);this.dataSorts=new Map;this.watches={};this.setSort("event",dataObj=>{if(!this.data.events[dataObj.timestamp])this.data.events[dataObj.timestamp]=[dataObj];else this.data.events[dataObj.timestamp].push(dataObj);if(dataObj.event==="sleep"){if(!this.data.sleep[dataObj.timestamp])this.data.sleep[dataObj.timestamp]=[dataObj];else this.data.sleep[dataObj.timestamp].push(dataObj)}return dataObj});this.setSort(["notes","note","link"],dataObj=>{if(!this.data.notes[dataObj.timestamp])this.data.notes[dataObj.timestamp]=[dataObj];else this.data.notes[dataObj.timestamp].push(dataObj);if(!this.data.byTime[dataObj.timestamp])this.data.byTime[dataObj.timestamp]=[dataObj];else this.data.byTime[dataObj.timestamp].push(dataObj);return dataObj});this.id=this.randomId("dataTablet")}randomId(tag=""){return`${tag+Math.floor(Math.random()+Math.random()*Math.random()*1e16)}`}setLocalData(structs){let setInCollection=s=>{let type=s.structType;let collection=this.collections.get(type);if(!collection){collection=new Map;this.collections.set(type,collection)}collection.set(s._id,s);this.onCollectionSet(type,collection)};if(Array.isArray(structs)){structs.forEach(s=>{setInCollection(s)})}else setInCollection(structs)}getLocalData(collection,query){let ownerId="";let key="";let value="";if(typeof query==="object"){ownerId=query.ownerId;const keys=Object.keys(query).filter(k2=>k2!="ownerId");key=keys[0];value=query[key]}else value=query;if(!collection&&!ownerId&&!key&&!value)return[];let result=[];if(!collection&&(ownerId||key)){this.collections.forEach(c=>{if((key==="_id"||key==="id")&&value){let found=c.get(value);if(found)result.push(found)}else{c.forEach(struct=>{if(key&&value){if(struct[key]===value&&struct.ownerId===ownerId){result.push(struct)}}else if(struct.ownerId===ownerId){result.push(struct)}})}});return result}else{let c=this.collections.get(collection);if(!c)return result;if(!key&&!ownerId){c.forEach(struct=>{result.push(struct)});return result}if((key==="_id"||key==="id")&&value)return c.get(value);else{c.forEach((struct,_)=>{if(key&&value&&!ownerId){if(struct[key]===value)result.push(struct)}else if(ownerId&&!key){if(struct.ownerId===ownerId)result.push(struct)}else if(ownerId&&key&&value){if(struct.ownerId===ownerId&&struct[key]){if(struct[key]===value)result.push(struct)}}})}}return result}onCollectionSet=(type,collection)=>{};runSort(key,dataObj={},newdata=[],tablet=this){let result;let sort=this.getSort(key);if(sort)result=sort(dataObj,newdata,tablet);else return false;return result}setSort(key,response=(data,newdata=[],tablet=this)=>{}){if(Array.isArray(key))key.forEach(k2=>{this.dataSorts.set(k2,response)});else this.dataSorts.set(key,response)}getSort(key){return this.dataSorts.get(key)}checkWatches(sorted={}){for(const prop in this.watches){let triggered=this.watches[prop].ondata(sorted,this.watches[prop].accum,this.watches[prop].ownerId);if(triggered){this.watches[prop].ontrigger(this.watches[prop].accum);this.watches[prop].triggered=false}}}setWatch(name,ownerId,ondata=(sorted,accum,ownerId2)=>{if(sorted.ownerId===ownerId2)accum.data[sorted._id]=sorted;if(Object.keys(accum.data).length>10){return true}else return false},ontrigger=accum=>{console.log(accum);let alert=Struct("alert",{alert:true,data:accum},{_id:accum[Object.keys(accum)[0]].ownerId});accum={}}){this.watches[name]={accum:{},ownerId,ondata,ontrigger}}getWatch(name){return this.watches[name]}async sortStructsIntoTable(datastructs=[]){let ascending=function(a,b2){if(a.timestamp&&b2.timestamp)return a.timestamp-b2.timestamp};datastructs.sort(ascending);let newdata=[];for(let i3=0;i3<datastructs.length;i3++){let struct=datastructs[i3];if(!struct.timestamp)continue;let timestamp=struct.timestamp;if(!this.data.byTime[timestamp])this.data.byTime[timestamp]=[struct];else this.data.byTime[timestamp].push(struct);if(struct.structType==="data"&&struct.data){struct.data.forEach(async dat=>{if(typeof dat==="object"&&!Array.isArray(dat)){let typ=dat.dataType;dat.ownerId=struct.ownerId;if(!dat.timestamp)dat.timestamp=timestamp;if(typ){let sorted=this.runSort(typ,dat,newdata,this);if(!sorted){if(!this.data[typ])this.data[typ]={};dat.timestamp=timestamp;if(!this.data[typ][timestamp])this.data[typ][timestamp]=[dat];else this.data[typ][timestamp].push(dat);if(!this.data.byTime[timestamp])this.data.byTime[timestamp]=[dat];else this.data.byTime[timestamp].push(dat);this.checkWatches(dat);this.onUpdate(timestamp,dat);newdata.push(dat)}else{if(sorted.constructor?.name!=="Promise"){this.checkWatches(sorted);this.onUpdate(timestamp,sorted);newdata.push(sorted)}}}}})}else{let sorted=this.runSort(struct.structType,struct,newdata,this);if(!sorted){let typ=struct.structType;if(!this.data[typ])this.data[typ]={};if(!this.data[typ][timestamp])this.data[typ][timestamp]=[struct];else this.data[typ][timestamp].push(struct);this.checkWatches(struct);this.onUpdate(timestamp,struct);newdata.push(struct)}else{this.checkWatches(sorted);this.onUpdate(timestamp,sorted);newdata.push(sorted)}}}for(const prop in this.data){this.data[prop]=this.sortObjectByPropName(this.data[prop])}this.onSorted(newdata)}onUpdate(_,__,___=this.data){}onSorted(_=[]){}getDataByTimestamp(timestamp,ownerId){let result=this.data.byTime[timestamp];if(ownerId&&result)result=result.filter(o=>{if(!ownerId)return true;else if(ownerId===o.ownerId)return true;else return false});return result}getDataByTimeRange(begin,end,type,ownerId){let result={};if(type){for(const key in this.data[type]){let t=parseInt(key);if(t>begin&&t<end){result[key]=[...this.data[type][key]]}}if(type==="sleep"){result=this.filterSleepResults(result)}}else{for(const key in this.data.byTime){let t=parseInt(key);if(t>begin&&t<end){result[key]=[...this.data.byTime[key]]}}}if(ownerId&&result){for(const key in result){let popidx=[];result[key]=result[key];result[key].forEach((o,i3)=>{if(o.ownerId!==ownerId){popidx.push(i3)}});popidx.reverse().forEach(idx=>{result[key].splice(idx,1)});if(result[key].length===0)delete result[key]}}return result}getDataByType(type,timestamp,ownerId){if(!this.data[type])return void 0;let result={...this.data[type]};if(timestamp)result=[...result[timestamp]];if(ownerId&&result){for(const key in result){let popidx=[];result[key]=[...result[key]];result[key].forEach((o,i3)=>{if(o.ownerId!==ownerId){popidx.push(i3)}});popidx.reverse().forEach(idx=>{result[key].splice(idx,1)});if(result[key].length===0)delete result[key]}}if(type==="sleep"){result=this.filterSleepResults(result)}return result}filterSleepResults(unfiltered={}){let events=[];for(const key in unfiltered){unfiltered[key]=[...unfiltered[key]];events.push(...unfiltered[key].filter(o=>{if(o.structType==="event")return true;else return false}))}events.forEach(ev=>{let foundidx;for(const key in unfiltered){unfiltered[key].forEach((o,i3)=>{if(o.structType==="fitbitsleep"&&ev.startTime&&ev.endTime){if(Math.abs(o.startTime-ev.startTime)<1e3*12*3600&&Math.abs(o.endTime-ev.endTime)<1e3*12*3600&&ev.endTime-ev.startTime>1e3*2*3600){foundidx=i3;return true}else return false}else return false});if(foundidx)unfiltered[key].splice(foundidx,1)}});let result=unfiltered;return result}sortObjectByPropName(object){const ordered=Object.keys(object).sort().reduce((obj,key)=>{obj[key]=object[key];return obj},{});return ordered}checkRollover(collection,limit=this.rolloverLimit){if(!collection)return false;let c=this.collections.get(collection);if(!c)return false;c.forEach(struct=>{for(const prop in struct){if(Array.isArray(struct[prop])){if(struct[prop].length>limit){struct[prop].slice(struct[prop].length-limit);if(prop==="ffts"){struct.fftCount=struct[prop].length}else if(prop==="times"){struct.count=struct[prop].length}}}else if(typeof struct[prop]==="object"){this.checkRollover(struct[prop])}}});return true}};var defaultSpecifiers=["now","minute","5 minutes","30 minutes","hour","6 hours","12 hours","day","3 days","week","2 weeks","month","6 months","year","5 years","decade"];function genTimeSpecifiers(specifiers=defaultSpecifiers){let result=["now"];specifiers.forEach(s=>{if(s!=="now")result.push(`last ${s}`);else result.push(s)});return result}function genTimestampFromString(specifier){const now=new Date;if(specifier==="now"){}else if(specifier==="last minute"){now.setMinutes(now.getMinutes()-1)}else if(specifier==="last hour"){now.setHours(now.getHours()-1)}else if(specifier==="last day"){now.setDate(now.getDate()-1)}else if(specifier==="last week"){now.setDate(now.getDate()-7)}else if(specifier==="last month"){now.setMonth(now.getMonth()-1)}else if(specifier==="last year"){now.setFullYear(now.getFullYear()-1)}else if(specifier==="last decade"){now.setFullYear(now.getFullYear()-1*10)}else if(specifier==="last century"){now.setFullYear(now.getFullYear()-1*100)}else if(specifier==="last millennium"){now.setFullYear(now.getFullYear()-1*1e3)}else if(specifier==="last microsecond"){now.setMilliseconds(now.getMilliseconds()-1)}else if(specifier==="last nanosecond"){now.setMilliseconds(now.getMilliseconds()-1*.001)}else if(specifier.startsWith("last")){const[,count,unit]=specifier.match(/last (\d+) (\w+)/)||[];if(count&&unit){const num=parseInt(count,10);if(unit.includes("minute")){now.setMinutes(now.getMinutes()-num)}else if(unit.includes("hour")){now.setHours(now.getHours()-num)}else if(unit.includes("day")){now.setDate(now.getDate()-num)}else if(unit.includes("week")){now.setDate(now.getDate()-num*7)}else if(unit.includes("month")){now.setMonth(now.getMonth()-num)}else if(unit.includes("year")){now.setFullYear(now.getFullYear()-num)}else if(unit.includes("decade")){now.setFullYear(now.getFullYear()-num*10)}else if(unit.includes("century")){now.setFullYear(now.getFullYear()-num*100)}else if(unit.includes("millennium")){now.setFullYear(now.getFullYear()-num*1e3)}else if(unit.includes("microsecond")){now.setMilliseconds(now.getMilliseconds()-num)}else if(unit.includes("nanosecond")){now.setMilliseconds(now.getMilliseconds()-num*.001)}}}return now.getTime()}var x=class{data={};triggers={};ctr=0;constructor(e){typeof e=="object"&&(this.data=e)}setState=e=>{Object.assign(this.data,e);let t=Object.getOwnPropertyNames(e);for(let n of t)this.triggerEvent(n,this.data[n]);if(this.triggers[G]){let n=r=>{r(e)},s=this.triggers[G].length;for(let r=s-1;r>=0;r--)n(this.triggers[G][r].onchange)}return this.data};setValue=(e,t)=>{this.data[e]=t,this.triggerEvent(e,t)};triggerEvent=(e,t)=>{if(this.triggers[e]){let n=r=>{r.onchange(t)},s=this.triggers[e].length;for(let r=s-1;r>=0;r--)n(this.triggers[e][r])}};subscribeState=e=>this.subscribeEvent(G,e);unsubscribeState=e=>this.unsubscribeEvent(G,e);subscribeEvent=(e,t,n,s)=>{if(e){n&&s&&!this.triggers[e]&&Object.defineProperty(this.data,e,{get:()=>n[s],set:_=>{n[s]=_},enumerable:true,configurable:true}),this.triggers[e]||(this.triggers[e]=[]);let r=this.ctr;return this.ctr++,this.triggers[e].push({sub:r,onchange:t}),r}else return};unsubscribeEvent=(e,t)=>{let n=this.triggers[e];if(n)if(t===void 0)delete this.triggers[e],delete this.data[e];else{let s,r=n.find((_,o)=>{if(_.sub===t)return s=o,true});return r&&n.splice(s,1),Object.keys(n).length===0&&(delete this.triggers[e],delete this.data[e]),this.onRemoved&&this.onRemoved(r),true}};subscribeEventOnce=(e,t)=>{let n,s=r=>{t(r),this.unsubscribeEvent(e,n)};return n=this.subscribeEvent(e,s),n};getEvent=(e,t)=>{if(typeof t!="number")return this.triggers[e];for(let n in this.triggers[e])if(this.triggers[e][n].sub===t)return this.triggers[e][n]};getSnapshot=()=>{let e={};for(let t in this.data)e[t]=this.data[t]};onRemoved};var G="*s";var q=new x;var w=class extends Function{__bound;__call;constructor(){return super("return this.__bound.__call.apply(this.__bound, arguments)"),this.__bound=this.bind(this),this.__bound}};var y=class i{__node={tag:`node${Math.floor(Math.random()*1e15)}`,unique:`${Math.floor(Math.random()*1e15)}`,state:q};__children;__parent;__operator;__listeners;__props;__args;constructor(e,t,n){if(this.__setProperties(e,t,n),typeof e=="function"||e?.__callable){let s=new w;s.__call=(..._)=>this.__operator(..._);let r=new Proxy(s,{get:(_,o,a)=>Reflect.has(this,o)?Reflect.get(this,o,a):Reflect.get(_,o,a),set:(_,o,a,f)=>Reflect.has(this,o)?Reflect.set(this,o,a,f):Reflect.set(_,o,a,f)});return Object.setPrototypeOf(r,this),r}}get __graph(){return this.__node?.graph}set __graph(e){this.__node.graph=e}__setProperties=(e,t,n)=>{if((()=>{let r=e;typeof e=="function"?S(e)?e=new e:e={__operator:e,__node:{forward:true,tag:e.name}}:typeof e=="string"&&n?.get(e)&&(e=n.get(e)),"__node"in e||(e.__node={}),e.__node.initial||(e.__node.initial=r)})(),typeof e=="object"){let r=()=>{e.__node?.state?this.__node.state=e.__node.state:n&&(e.__node.state=n.__node.state)},_=()=>{e.__props&&(typeof e.__props=="function"&&(e.__props=new e.__props),typeof e.__props=="object"&&this.__proxyObject(e.__props))},o=()=>{e.__node.tag||(e.__operator?.name?e.__node.tag=e.__operator.name:e.__node.tag=`node${Math.floor(Math.random()*1e15)}`)},a=()=>{typeof e.__node=="string"?n?.get(e.__node.tag)?e=n.get(e.__node.tag):e.__node={}:e.__node||(e.__node={}),n&&(e.__node.graph=n),e instanceof b&&(e.__node.source=e)},f=()=>{if(!e.__parent&&t&&(e.__parent=t),t?.__node&&!(t instanceof b||e instanceof b)&&(e.__node.tag=t.__node.tag+"."+e.__node.tag),t instanceof b&&e instanceof b&&(e.__node.loaders&&Object.assign(t.__node.loaders?t.__node.loaders:{},e.__node.loaders),t.__node.mapGraphs)){e.__node.nodes.forEach(h=>{t.set(e.__node.tag+"."+h.__node.tag,h)});let u=()=>{e.__node.nodes.forEach(h=>{t.__node.nodes.delete(e.__node.tag+"."+h.__node.tag)})};this.__addOndisconnected(u)}},l=()=>{if(typeof e.default=="function"&&!e.__operator&&(e.__operator=e.default),e.__operator){if(typeof e.__operator=="string"&&n){let u=n.get(e.__operator);u&&(e.__operator=u.__operator),!e.__node.tag&&e.__operator.name&&(e.__node.tag=e.__operator.name)}typeof e.__operator=="function"&&(e.__operator=this.__setOperator(e.__operator)),e.default&&(e.default=e.__operator)}},c=()=>{e.__node=Object.assign(this.__node,e.__node);let u=Object.getOwnPropertyNames(e).filter(h=>{if(!O[h])return true});for(let h of u)h in e&&h!=="name"&&(this[h]=e[h])},d=()=>{this.__onconnected&&(typeof this.__onconnected=="function"?this.__onconnected=this.__onconnected.bind(this):Array.isArray(this.__onconnected)&&(this.__onconnected=this.__onconnected.map(u=>u.bind(this))),typeof this.__ondisconnected=="function"?this.__ondisconnected=this.__ondisconnected.bind(this):Array.isArray(this.__ondisconnected)&&(this.__ondisconnected=this.__ondisconnected.map(u=>u.bind(this))))};r(),o(),_(),a(),f(),c(),d(),l()}};__subscribe=(e,t,n,s,r,_,o)=>{let a=(l,c=(u,h)=>h||u,d=e)=>{let u;if(_){let p=j(d,_,this.__node.graph);d=p.__callback,u=p.__args}let h=this.__node.state.subscribeEvent(l,d,this,t),g=this.__node.state.getEvent(l,h);return this.__listeners||(this.__listeners={}),this.__listeners[l]=this.__node.state.triggers[l],g&&(g.source=this.__node.tag,t&&(g.key=t),g.target=c(e,s),r&&(g.tkey=r),n&&(g.subInput=n),_&&(g.arguments=u,g.__args=_),o&&(g.__callback=o),g.node=this,g.graph=this.__node.graph),h},f=l=>{let c=this.__node.graph.get(l);if(!c&&l.includes(".")){s=l.substring(0,l.lastIndexOf("."));let d=this.__node.graph.get(l.substring(0,s));r=l.lastIndexOf(".")+1,d&&typeof d[t]=="function"&&(l=(...u)=>d[r](...u))}else c.__operator&&(l=c.__operator,r="__operator");return l};if(t){if((!this.__node.localState||!this.__node.localState[t])&&this.__addLocalState(this,t),typeof e=="string"){if(o=this.__node.tag+"."+e,r=e,s){if(this.__node.graph?.get(s)){let d=this.__node.graph?.get(s);if(typeof d[e]=="function"){let u=d[e];e=(...h)=>{u(...h)}}else{let u=e;e=g=>{d[u]=g}}}}else if(typeof this[e]=="function"){let d=this[e];e=(...u)=>{d(...u)}}else this.__node.graph?.get(e)&&(e=f(e));if(typeof e!="function")return}let l,c=n?this.__node.unique+"."+t+"input":this.__node.unique+"."+t;return typeof e=="function"&&!e?.__node?l=a(c,(d,u)=>u||d,e):e?.__node&&(l=a(c,(d,u)=>u||d.__node.unique,(...d)=>{e.__operator&&e.__operator(...d)})),l}else{if(typeof e=="string"&&(o=e,s||(s=e),this.__node.graph.get(e)&&(e=this.__node.graph.get(e)),r="__operator",typeof e!="object"))return;let l,c=n?this.__node.unique+"input":this.__node.unique;return typeof e=="function"&&!e?.__node?l=a(c,(d,u)=>u||d,e):e?.__node&&(l=a(c,(d,u)=>u||d.__node.unique,(...d)=>{e.__operator&&e.__operator(...d)})),l}};__unsubscribe=(e,t,n)=>t?this.__node.state.unsubscribeEvent(n?this.__node.unique+"."+t+"input":this.__node.unique+"."+t,e):this.__node.state.unsubscribeEvent(n?this.__node.unique+"input":this.__node.unique,e);__setOperator=e=>{e=e.bind(this),this.__args&&this.__node.graph&&(e=j(e,this.__args,this.__node.graph).__callback);let t=`${this.__node.unique}input`;if(this.__operator=(...n)=>{this.__node.state.triggers[t]&&this.__node.state.setValue(t,n);let s=e(...n);return this.__node.state.triggers[this.__node.unique]&&(typeof s?.then=="function"?s.then(r=>{r!==void 0&&this.__node.state.setValue(this.__node.unique,r)}).catch(console.error):s!==void 0&&this.__node.state.setValue(this.__node.unique,s)),s},this.__parent instanceof i&&!this.__subscribedToParent&&this.__parent.__operator){let n=this.__parent.__subscribe(this),s=()=>{this.__parent?.__unsubscribe(n),delete this.__subscribedToParent};this.__addOndisconnected(s),this.__subscribedToParent=true}return this.__operator};__addLocalState=(e,t)=>{if(!e)return;this.__node.localState||(this.__node.localState={});let n=this.__node.localState,s=(r,_)=>{let o=this.__node.unique+"."+_,a=`${o}input`,f,l,c,d;if(typeof r[_]=="function"&&_!=="__operator")this.__props?.[_]?c=this.__props:c=n,f=()=>c[_],l=u=>{this.__props?.[_]||(u=u.bind(this)),c[_]=(...h)=>{this.__node.state.triggers[a]&&this.__node.state.setValue(a,h);let g=u(...h);return this.__node.state.triggers[o]&&(typeof g?.then=="function"?g.then(p=>{this.__node.state.triggerEvent(o,p)}).catch(console.error):this.__node.state.triggerEvent(o,g)),g}},n[_]=r[_].bind(this),d={get:f,set:l,enumerable:true,configurable:true};else if(_!=="__graph"){let u,h,g;this.__props?.[_]?g=this.__props:g=n,u=()=>g[_],h=p=>{g[_]=p,this.__node.state.triggers[o]&&this.__node.state.triggerEvent(o,p)},n[_]=r[_],d={get:u,set:h,enumerable:true,configurable:true}}if(Object.defineProperty(r,_,d),typeof this.__node.initial=="object"){let u=Object.getOwnPropertyDescriptor(this.__node.initial,_);(u===void 0||u?.configurable)&&Object.defineProperty(this.__node.initial,_,d)}};if(t)s(e,t);else for(let r in e)s(e,r)};__proxyObject=e=>{let t=I(e);for(let n of t){let s={get:()=>e[n],set:r=>{e[n]=r},enumerable:true,configurable:true};if(Object.defineProperty(this,n,s),typeof this.__node.initial=="object"){let r=Object.getOwnPropertyDescriptor(this.__node.initial,n);(r===void 0||r?.configurable)&&Object.defineProperty(this.__node.initial,n,s)}}};__addOnconnected(e){e=e.bind(this),Array.isArray(this.__onconnected)?this.__onconnected.push(e):typeof this.__onconnected=="function"?this.__onconnected=[e,this.__onconnected]:this.__onconnected=e}__addOndisconnected(e){e=e.bind(this),Array.isArray(this.__ondisconnected)?this.__ondisconnected.push(e):typeof this.__ondisconnected=="function"?this.__ondisconnected=[e,this.__ondisconnected]:this.__ondisconnected=e}__callConnected(e=this){if(typeof this.__onconnected=="function")this.__onconnected(this);else if(Array.isArray(this.__onconnected)){let t=n=>{n(this)};this.__onconnected.forEach(t)}}__callDisconnected(e=this){if(typeof this.__ondisconnected=="function")this.__ondisconnected(this);else if(Array.isArray(this.__ondisconnected)){let t=n=>{n(this)};this.__ondisconnected.forEach(t)}}};var b=class i2{__node={tag:`graph${Math.floor(Math.random()*1e15)}`,unique:`${Math.random()}`,nodes:new Map,state:q,roots:{}};constructor(e){this.init(e)}init=e=>{if(e){let t=Object.assign({},e);delete t.roots,N(this.__node,t),e.roots&&this.load(e.roots)}};load=(e,t=false)=>{function n(_,o,a=true,f=true){if(f){_||(_={});for(let l in o)!l.startsWith("__")&&o[l]&&typeof o[l]=="object"?(_[l]=o[l],o[l]?.__children&&n({},o[l].__children,false,false)):typeof o[l]=="function"&&(_[l]=o[l]);n(_,o,true,false)}else if(o?.__children&&!a)o.__children?.constructor.name==="Object"?_.__children?.constructor.name==="Object"?_.__children=n(_.__children,o.__children,true,false):_.__children=n({},o.__children,true,false):_.__children=o.__children;else if(a)for(let l in o)!l.startsWith("__")&&o[l]&&typeof o[l]=="object"?(_[l]=Object.assign({},o[l]),o[l]?.__children&&(_[l].__children=n({},o[l].__children,false,false))):typeof o[l]=="function"&&(_[l]=o[l]);return _}this.__node.roots=n(this.__node.roots?this.__node.roots:{},e);let s=Object.assign({},e);s.__node&&delete s.__node;let r=this.recursiveSet(s,this,void 0,e,t);if(e.__node){if(!e.__node.tag)e.__node._tag=`roots${Math.floor(Math.random()*1e15)}`;else if(!this.get(e.__node.tag)){let _=new y(e,this,this);this.set(_.__node.tag,_),this.runLoaders(_,this,e,e.__node.tag),_.__listeners&&(r[_.__node.tag]=_.__listeners)}}else e.__listeners&&this.setListeners(e.__listeners);return this.setListeners(r),s};setLoaders=(e,t)=>(t?this.__node.loaders=e:Object.assign(this.__node.loaders,e),this.__node.loaders);runLoaders=(e,t,n,s)=>{for(let r in this.__node.loaders)typeof this.__node.loaders[r]=="object"?(this.__node.loaders[r].init&&this.__node.loaders[r](e,t,this,this.__node.roots,n,s),this.__node.loaders[r].connected&&e.__addOnconnected(this.__node.loaders[r].connect),this.__node.loaders[r].disconnected&&e.__addOndisconnected(this.__node.loaders[r].disconnect)):typeof this.__node.loaders[r]=="function"&&this.__node.loaders[r](e,t,this,this.__node.roots,n,s)};add=(e,t,n=true)=>{let s={};typeof t=="string"&&(t=this.get(t));let r;if(typeof e=="function"?S(e)?e.prototype instanceof y?(e=e.prototype.constructor(e,t,this),r=true):e=new e:e={__operator:e,__callable:true}:typeof e=="string"&&(e=this.__node.roots[e]),!e)return;if(!r){let a=Object.getOwnPropertyNames(e),f=Object.getOwnPropertyNames(Object.getPrototypeOf(e));a.push(...f),a=a.filter(c=>!O.includes(c));let l={};for(let c of a)l[c]=e[c];e=l}if(e.__node||(e.__node={}),e.__node.initial=e,typeof e=="object"&&this.get(e.__node.tag))if(n)this.remove(e.__node.tag,true);else return;else if(e.__node.tag&&this.get(e.__node.tag))return this.get(e.__node.tag);let _,o=N({},e,2);if(r?_=e:_=new y(e,t,this),this.set(_.__node.tag,_),this.runLoaders(_,t,e,_.__node.tag),this.__node.roots[_.__node.tag]=o,_.__children&&(_.__children=Object.assign({},_.__children),this.recursiveSet(_.__children,_,s,_.__children)),_.__listeners){s[_.__node.tag]=Object.assign({},_.__listeners);for(let a in _.__listeners){let f=_.__listeners[a];_[a]&&(delete s[_.__node.tag][a],s[_.__node.tag][_.__node.tag+"."+a]=f),typeof f=="string"&&(_.__children?.[f]?s[_.__node.tag][a]=_.__node.tag+"."+f:t instanceof y&&(t.__node.tag===f||t.__node.tag.includes(".")&&t.__node.tag.split(".").pop()===f)&&(s[_.__node.tag][a]=t.__node.tag))}}return this.setListeners(s),_.__callConnected(),_};recursiveSet=(e,t,n={},s,r=false)=>{let _=Object.getOwnPropertyNames(s).filter(a=>!O.includes(a)),o=Object.getOwnPropertyNames(Object.getPrototypeOf(s)).filter(a=>!O.includes(a));_.push(...o);for(let a of _){if(a.includes("__"))continue;let f=s[a];if(Array.isArray(f))continue;let l;if(typeof f=="function"?S(f)?(f=new f,f instanceof y&&(f=f.prototype.constructor(f,t,this),l=true)):f={__operator:f,__callable:true}:typeof f=="string"?this.__node.nodes.get(f)?f=this.__node.nodes.get(f):f=this.__node.roots[f]:typeof f=="boolean"&&(this.__node.nodes.get(a)?f=this.__node.nodes.get(a):f=this.__node.roots[a]),f&&typeof f=="object"){if(!l&&!(f instanceof y)){let h=Object.getOwnPropertyNames(f).filter(m=>!O.includes(m)),g=Object.getOwnPropertyNames(Object.getPrototypeOf(f)).filter(m=>!O.includes(m));g.splice(g.indexOf("constructor"),1),h.push(...g);let p={};for(let m of h)p[m]=f[m];f=p}if(f.__node||(f.__node={}),f.__node.tag||(f.__node.tag=a),f.__node.initial||(f.__node.initial=e[a]),r&&this.get(f.__node.tag))this.remove(f.__node.tag,true);else if(this.get(f.__node.tag)&&!(!(t instanceof i2)&&t?.__node)||t?.__node&&this.get(t.__node.tag+"."+f.__node.tag))continue;let c,d=false,u=N({},f,2);if(l||f instanceof y?c=f:(c=new y(f,t,this),d=true),!d&&f instanceof y&&!l&&t instanceof y){let h=this.subscribe(t.__node.tag,c.__node.tag),g=p=>{this.unsubscribe(t.__node.tag,h)};c.__addOndisconnected(g)}else if(c){if(this.set(c.__node.tag,c),this.runLoaders(c,t,e[a],a),e[a]=c,this.__node.roots[c.__node.tag]=u,c.__children&&(c.__children=Object.assign({},c.__children),this.recursiveSet(c.__children,c,n,c.__children)),c.__listeners){n[c.__node.tag]=Object.assign({},c.__listeners);for(let h in c.__listeners){let g=c.__listeners[h],p=h;c[h]&&(delete n[c.__node.tag][h],p=c.__node.tag+"."+h,n[c.__node.tag][p]=g),typeof g=="string"&&(c.__children?.[g]?n[c.__node.tag][p]=c.__node.tag+"."+g:t instanceof y&&(t.__node.tag===g||t.__node.tag.includes(".")&&t.__node.tag.split(".").pop()===g)&&(n[c.__node.tag][p]=t.__node.tag))}}c.__callConnected()}}}return n};remove=(e,t=true)=>{if(this.unsubscribe(e),typeof e=="string"&&(e=this.get(e)),e instanceof y){this.delete(e.__node.tag),delete this.__node.roots[e.__node.tag],t&&this.clearListeners(e),e.__callDisconnected();let n=s=>{for(let r in s)this.unsubscribe(s[r]),this.delete(s[r].__node.tag),delete this.__node.roots[s[r].__node.tag],this.delete(r),delete this.__node.roots[r],s[r].__node.tag=s[r].__node.tag.substring(s[r].__node.tag.lastIndexOf(".")+1),t&&this.clearListeners(s[r]),s[r].__callDisconnected(),s[r].__children&&n(s[r].__children)};e.__children&&n(e.__children)}return e?.__node.tag&&e?.__parent&&(delete e?.__parent,e.__node.tag=e.__node.tag.substring(e.__node.tag.indexOf(".")+1)),e?.__node.graph&&(e.__node.graph=void 0),e};run=(e,...t)=>{if(typeof e=="string"){let n=this.get(e);if(!n&&e.includes(".")){if(n=this.get(e.substring(0,e.lastIndexOf("."))),typeof n?.[e.substring(e.lastIndexOf(".")+1)]=="function")return n[e.substring(e.lastIndexOf(".")+1)](...t)}else if(n?.__operator)return n.__operator(...t)}if(e?.__operator)return e?.__operator(...t)};setListeners=e=>{for(let t in e){let n=this.get(t);if(typeof e[t]=="object")for(let s in e[t]){let r=this.get(s),_;if(typeof e[t][s]!="object")e[t][s]={__callback:e[t][s]};else if(!e[t][s].__callback)for(let o in e[t][s]){typeof e[t][s][o]!="object"&&(e[t][s][o]={__callback:e[t][s][o]},n.__operator&&(e[t][s][o].__callback===true||typeof e[t][s][o].__callback>"u")&&(e[t][s][o].__callback=n.__operator));let a=this.get(o);if(a)_=this.subscribe(a,e[t][s][o].__callback,e[t][s][o].__args,void 0,e[t][s][o].subInput,t);else{let f=s.substring(0,s.lastIndexOf("."));if(a=this.get(f),a){let l=s.substring(s.lastIndexOf(".")+1);_=this.subscribe(a,e[t][s][o].__callback,e[t][s][o].__args,l,e[t][s][o].subInput,t)}}}if("__callback"in e[t][s])if(n&&((e[t][s].__callback===true||typeof e[t][s].__callback>"u")&&(e[t][s].__callback=n.__operator),typeof e[t][s].__callback=="function"&&(e[t][s].__callback=e[t][s].__callback.bind(n))),r)_=this.subscribe(r,e[t][s].__callback,e[t][s].__args,void 0,e[t][s].subInput,t);else{let o=s.substring(0,s.lastIndexOf("."));r=this.get(o),r&&(_=this.subscribe(r,e[t][s].__callback,e[t][s].__args,s.substring(s.lastIndexOf(".")+1),e[t][s].subInput,t))}}}};clearListeners=(e,t)=>{if(typeof e=="string"&&(e=this.get(e)),e?.__listeners)for(let n in e.__listeners){if(t&&n!==t||typeof e.__listeners[n]?.sub!="number")continue;let s=this.get(n);if(s)if(typeof!e.__listeners[n]?.__callback=="number")for(let r in e.__listeners[n])e.__listeners[n][r]?.sub&&(this.unsubscribe(s,e.__listeners[n][r].sub,void 0,e.__listeners[n][r].subInput),e.__listeners[n][r].sub=void 0);else typeof e.__listeners[n]?.sub=="number"&&(this.unsubscribe(s,e.__listeners[n].sub,void 0,e.__listeners[n].subInput),e.__listeners[n].sub=void 0);else if(s=this.get(n.substring(0,n.lastIndexOf("."))),s)if(typeof e.__listeners[n]=="object"&&!e.__listeners[n]?.__callback)for(let r in e.__listeners[n])typeof e.__listeners[n][r]?.sub=="number"&&(this.unsubscribe(s,e.__listeners[n][r].sub,n.substring(n.lastIndexOf(".")+1),e.__listeners[n][r].subInput),e.__listeners[n][r].sub=void 0);else typeof e.__listeners[n]?.sub=="number"&&(this.unsubscribe(s,e.__listeners[n].sub,n.substring(n.lastIndexOf(".")+1),e.__listeners[n].subInput),e.__listeners[n].sub=void 0)}};get=e=>this.__node.nodes.get(e);getByUnique=e=>Array.from(this.__node.nodes.values()).find(t=>{if(t.__node.unique===e)return true});set=(e,t)=>this.__node.nodes.set(e,t);delete=e=>this.__node.nodes.delete(e);list=()=>Array.from(this.__node.nodes.keys());getListener=(e,t,n)=>{let s=this.get(e);if(s){let r=s.__node.unique;return t&&(r+="."+t),this.__node.state.getEvent(r,n)}};getProps=(e,t)=>{if(typeof e=="string"&&(e=this.get(e)),e instanceof y){let n;if(t)n=Object.assign({},this.__node.roots[e.__node.tag]);else{n=Object.assign({},e);for(let s in n)s.includes("__")&&delete n[s]}}};subscribe=(e,t,n,s,r,_,o)=>{let a=e;typeof e=="string"&&(a=this.get(e),!a&&e.includes(".")&&(a=this.get(e.substring(0,e.lastIndexOf("."))),s=e.substring(e.lastIndexOf(".")+1))),_ instanceof y&&(_=_.__node.tag);let f;if(typeof t=="string"){f=t;let c=d=>{if(this.get(d)?.__operator){let u=this.get(d);_=d,d=function(...h){return u.__operator(...h)}}else if(d.includes(".")){_=d.substring(0,d.lastIndexOf("."));let u=this.get(_),h=d.substring(d.lastIndexOf(".")+1);o=h,typeof u[h]=="function"?u[h]instanceof y?d=u[h]:d=function(...g){return u[h](...g)}:d=function(g){return u[h]=g,u[h]}}return d};if(_){let d=this.get(_);typeof d?.[t]=="function"?(o=t,t=function(...u){return d[s](...u)}):d?.[s]?(o=s,d[s]instanceof y?t=d[s]:t=function(u){return d[s]=u,d[s]}):t=c(t)}else t=c(t)}let l;if(a instanceof y){let c=()=>{l=a.__subscribe(t,s,r,_,o,n,f);let d=()=>{l!==void 0&&a.__unsubscribe(l,s,r),l=void 0};a.__addOndisconnected(()=>{d(),a.__addOnconnected(()=>{l===void 0&&a.__node.graph.__node.tag===this.__node.tag&&c()})}),typeof t=="string"&&this.get(t)&&(t=this.get(t)),t instanceof y&&t.__addOndisconnected(()=>{d()})};c()}else if(typeof e=="string"){let c=this.get(e);if(c){if(t instanceof y&&t.__operator){let d=()=>{l=c.__subscribe(t.__operator,s,r,_,o,n,f);let u=()=>{l!==void 0&&c.__unsubscribe(l,s,r)};c.__addOndisconnected(()=>{u(),c.__addOnconnected(()=>{l===void 0&&c.__node.graph.__node.tag===this.__node.tag&&d()})}),t.__addOndisconnected(u)};d()}else if(typeof t=="function"||typeof t=="string"){let d=()=>{l=c.__subscribe(t,s,r,_,o,n,f);let u=()=>{l!==void 0&&c.__unsubscribe(l,s,r),l=void 0};c.__addOndisconnected(()=>{u(),c.__addOnconnected(()=>{l===void 0&&c.__node.graph.__node.tag===this.__node.tag&&d()})}),typeof t=="string"&&this.get(t)&&this.get(t).__addOndisconnected(u)};d()}}else typeof t=="string"&&(t=this.__node.nodes.get(t).__operator),typeof t=="function"&&!t?.__node&&(l=this.__node.state.subscribeEvent(e,t))}return l};unsubscribe=(e,t,n,s)=>e instanceof y?e.__unsubscribe(t,n,s):this.get(e)?.__unsubscribe(t,n,s);setState=e=>{this.__node.state.setState(e)}};function N(i3,e,t=1/0,n=0){for(let s in e)e[s]?.constructor.name==="Object"&&n<t?(n++,i3[s]?.constructor.name==="Object"?N(i3[s],e[s],t,n):i3[s]=N({},e[s],t,n)):i3[s]=e[s];return i3}function I(i3){var e=[],t=i3;do{var n=Object.getOwnPropertyNames(t);let s=function(r){e.indexOf(r)===-1&&e.push(r)};n.forEach(s)}while(t=Object.getPrototypeOf(t));return e}function S(i3){return R(i3)==="class"}function R(i3){return typeof i3=="function"?i3.prototype?Object.getOwnPropertyDescriptor(i3,"prototype")?.writable?"function":"class":i3.constructor.name==="AsyncFunction"?"async":"arrow":""}var A=(i3,e)=>{if(e.get(i3)?.__operator){let t=e.get(i3);return(...n)=>{t.__operator(...n)}}else if(i3.includes(".")){let t=i3.split("."),n=t.pop(),s=t.join("."),r=e.get(s);return typeof e.get(s)?.[n]=="function"?(..._)=>r[n](..._):()=>r[n]}else if(e.get(i3)){let t=e.get(i3);return()=>t}else{let t=i3;return()=>t}};var j=(i3,e,t)=>{let n=[],s=(_,o)=>{if(_==="__output"||_==="__input"||_==="__callback")n[o]={__callback:a=>a,__args:void 0,idx:o};else if(typeof _=="string")n[o]={__callback:A(_,t),__args:void 0,idx:o};else if(typeof _=="function"){let a=_;n[o]={__callback:(...f)=>a(...f),__args:void 0,idx:o}}else if(typeof _=="object"&&(_.__input||_.__callback)){let a=function(f){let l=f.__input?f.__input:f.__callback;if(typeof f.__input=="string"&&(l={__callback:A(f.__input,t),__args:void 0,idx:o}),f.__args){let c=j(l,f.__args,t);l={__callback:c.__callback,__args:c.__args,idx:o}}else l={__callback:l,__args:void 0,idx:o};if(f.__output){let c=f.__output;if(typeof f.__output=="string"?c={__callback:A(c,t),__args:void 0,idx:o}:typeof _.__output=="object"&&(c=a(c)),typeof c?.__callback=="function"){let d=l.__callback,u=c.__callback;l={__callback:(...h)=>u(d(...h)),__args:c.__args,idx:o}}}return l};n[o]=a(_)}else{let a=_;n[o]={__callback:()=>a,__args:void 0,idx:o}}};e.forEach(s),typeof i3=="string"&&(i3={__callback:A(i3,t),__args:void 0});let r=typeof i3=="function"?i3:i3.__callback;return i3=function(..._){let o=f=>f.__callback(..._);return r(...n.map(o))},{__callback:i3,__args:n}};var O=Object.getOwnPropertyNames(Object.getPrototypeOf({}));var C=(i3,e,t)=>{i3.__node.backward&&e instanceof y&&t.setListeners({[e.__node.tag]:{[i3.__node.tag]:e}})};var T=(i3,e,t)=>{if(i3.__operator){let n=Math.random();if(i3.__node.loops||(i3.__node.loops={}),typeof i3.__node.delay=="number"){let s=i3.__operator;i3.__setOperator((...r)=>new Promise((_,o)=>{i3.__node.loops[n]=setTimeout(async()=>{_(await s(...r))},i3.__node.delay)}))}else if(i3.__node.frame===true){let s=i3.__operator;i3.__setOperator((...r)=>new Promise((_,o)=>{i3.__node.loops[n]=requestAnimationFrame(async()=>{_(await s(...r))})}))}if(typeof i3.__node.repeat=="number"||typeof i3.__node.recursive=="number"){let s=i3.__operator;i3.__setOperator(async(...r)=>{let _=i3.__node.repeat?i3.__node.repeat:i3.__node.recursive,o,a=async(f,...l)=>{for(;f>0;){if(i3.__node.delay||i3.__node.frame){s(...l).then(async c=>{i3.__node.recursive?await a(f,c):await a(f,...l)});break}else o=await s(...r);f--}};return await a(_,...r),o})}if(i3.__node.loop&&typeof i3.__node.loop=="number"){let s=i3.__operator,r=i3.__node.loop;i3.__setOperator((...o)=>{if("looping"in i3.__node||(i3.__node.looping=true),i3.__node.looping){let a=performance.now();s(...o),i3.__node.loops[n]=setTimeout(()=>{let l=performance.now()-a-i3.__node.loop;l>0?r=i3.__node.loop-l:r=i3.__node.loop,r<=0&&(r=i3.__node.loop),i3.__operator(...o)},r)}}),i3.__node.looping&&i3.__operator();let _=o=>{o.__node.looping&&(o.__node.looping=false),o.__node.loops[n]&&(clearTimeout(o.__node.loops[n]),cancelAnimationFrame(o.__node.loops[n]))};i3.__addOndisconnected(_)}}};var $=(i3,e,t)=>{if(i3.__node.animate===true||i3.__animation){let n=i3.__operator;i3.__setOperator((...r)=>{"animating"in i3.__node||(i3.__node.animating=true),i3.__node.animating&&(typeof i3.__animation=="function"?i3.__animation(...r):n(...r),i3.__node.animationFrame=requestAnimationFrame(()=>{i3.__operator(...r)}))}),(i3.__node.animating||(!("animating"in i3.__node)||i3.__node.animating)&&i3.__animation)&&setTimeout(()=>{i3.__node.animationFrame=requestAnimationFrame(i3.__operator)},10);let s=r=>{r.__node.animating&&(r.__node.animating=false),r.__node.animationFrame&&cancelAnimationFrame(r.__node.animationFrame)};i3.__addOndisconnected(s)}};var J=(i3,e,t)=>{if(typeof i3.__branch=="object"&&i3.__operator&&!i3.__branchApplied){let n=i3.__operator;i3.__branchApplied=true,i3.__operator=(...s)=>{let r=n(...s);for(let _ in i3.__branch){let o=()=>{typeof i3.__branch[_].then=="function"?i3.__branch[_].then(r):i3.__branch[_].then instanceof y&&i3.__branch[_].then.__operator?i3.__branch[_].then.__operator(r):r=i3.__branch[_].then};typeof i3.__branch[_].if=="function"?i3.__branch[_].if(r)==true&&o():i3.__branch[_].if===r&&o()}return r}}if(i3.__listeners){for(let n in i3.__listeners)if(typeof i3.__listeners[n]=="object"&&i3.__listeners[n].branch&&!i3.__listeners[n].branchApplied){let s=i3.__listeners[n].callback;i3.__listeners[n].branchApplied=true,i3.__listeners.callback=r=>{let _=()=>{typeof i3.__listeners[n].branch.then=="function"?r=i3.__listeners[n].branch.then(r):i3.__listeners[n].branch.then instanceof y&&i3.__listeners[n].branch.then.__operator?r=i3.__listeners[n].branch.then.__operator(r):r=i3.__listeners[n].branch.then};return typeof i3.__listeners[n].branch.if=="function"?i3.__listeners[n].branch.if(r)&&_():i3.__listeners[n].branch.if===r&&_(),s(r)}}}};var W=(i3,e,t)=>{if(i3.__listeners)for(let n in i3.__listeners)typeof i3.__listeners[n]=="object"&&i3.__listeners[n].oncreate&&i3.__listeners[n].callback(i3.__listeners[n].oncreate)};var V=(i3,e,t)=>{if(i3.__listeners)for(let n in i3.__listeners)typeof i3.__listeners[n]=="object"&&typeof i3.__listeners[n].binding=="object"&&(i3.__listeners.callback=i3.__listeners.callback.bind(i3.__listeners[n].binding))};var B=(i3,e,t)=>{if(i3.__listeners){for(let n in i3.__listeners)if(typeof i3.__listeners[n]=="object"&&typeof i3.__listeners[n].transform=="function"&&!i3.__listeners[n].transformApplied){let s=i3.__listeners[n].callback;i3.__listeners[n].transformApplied=true,i3.__listeners.callback=r=>(r=i3.__listeners[n].transform(r),s(r))}}};var H=(i3,e,t)=>{i3.post&&!i3.__operator?i3.__setOperator(i3.post):!i3.__operator&&typeof i3.get=="function"&&i3.__setOperator(i3.get),!i3.get&&i3.__operator,i3.aliases&&i3.aliases.forEach(n=>{t.set(n,i3);let s=r=>{t.__node.nodes.delete(n)};i3.__addOndisconnected(s)}),typeof t.__node.roots?.[i3.__node.tag]=="object"&&i3.get&&(t.__node.roots[i3.__node.tag].get=i3.get)};var F={backprop:C,loop:T,animate:$,branching:J,triggerListenerOncreate:W,bindListener:V,transformListenerResult:B,substitute__operator:H};var k=function(){let i3=new Map,e=[],t=["this"];function n(){i3.clear(),e.length=0,t.length=1}function s(_,o){var a=e.length-1,f=e[a];if(typeof f=="object")if(f[_]===o||a===0)t.push(_),e.push(o.pushed);else for(;a-->=0;){if(f=e[a],typeof f=="object"&&f[_]===o){a+=2,e.length=a,t.length=a,--a,e[a]=o,t[a]=_;break}a--}}function r(_,o){if(o!=null&&typeof o=="object"){_&&s(_,o);let a=i3.get(o);if(a)return"[Circular Reference]"+a;i3.set(o,t.join("."))}return o}return function(o,a){try{return e.push(o),JSON.stringify(o,r,a)}finally{n()}}}();JSON.stringifyWithCircularRefs===void 0&&(JSON.stringifyWithCircularRefs=k);var z=function(){let i3=new Map,e=[],t=["this"];function n(){i3.clear(),e.length=0,t.length=1}function s(_,o){var a=e.length-1,f=e[a];if(typeof f=="object")if(f[_]===o||a===0)t.push(_),e.push(o.pushed);else for(;a-->=0;){if(f=e[a],typeof f=="object"&&f[_]===o){a+=2,e.length=a,t.length=a,--a,e[a]=o,t[a]=_;break}a--}}function r(_,o){if(o!=null&&typeof o=="object"){_&&s(_,o);let a=i3.get(o);if(a)return"[Circular Reference]"+a;i3.set(typeof o=="function"?o.toString():o,t.join("."))}return typeof o=="function"?o.toString():o}return function(o,a){try{return e.push(o),JSON.stringify(o,r,a)}finally{n()}}}();JSON.stringifyWithFunctionsAndCircularRefs===void 0&&(JSON.stringifyWithFunctionsAndCircularRefs=z);var Q=function(){let i3=new Map,e=[],t=["this"];function n(){i3.clear(),e.length=0,t.length=1}function s(_,o){var a=e.length-1;if(e[a]){var f=e[a];if(typeof f=="object")if(f[_]===o||a===0)t.push(_),e.push(o.pushed);else for(;a-->=0;){if(f=e[a],typeof f=="object"&&f[_]===o){a+=2,e.length=a,t.length=a,--a,e[a]=o,t[a]=_;break}a++}}}function r(_,o){let a;if(o!=null)if(typeof o=="object"){let f=o.constructor.name;_&&f==="Object"&&s(_,o);let l=i3.get(o);if(l)return"[Circular Reference]"+l;if(i3.set(o,t.join(".")),f==="Array")o.length>20?a=o.slice(o.length-20):a=o;else if(f.includes("Set"))a=Array.from(o);else if(f!=="Object"&&f!=="Number"&&f!=="String"&&f!=="Boolean")a="instanceof_"+f;else if(f==="Object"){let c={};for(let d in o)if(o[d]==null)c[d]=o[d];else if(Array.isArray(o[d]))o[d].length>20?c[d]=o[d].slice(o[d].length-20):c[d]=o[d];else if(o[d].constructor.name==="Object"){c[d]={};for(let u in o[d])if(Array.isArray(o[d][u]))o[d][u].length>20?c[d][u]=o[d][u].slice(o[d][u].length-20):c[d][u]=o[d][u];else if(o[d][u]!=null){let h=o[d][u].constructor.name;h.includes("Set")?c[d][u]=Array.from(o[d][u]):h!=="Number"&&h!=="String"&&h!=="Boolean"?c[d][u]="instanceof_"+h:c[d][u]=o[d][u]}else c[d][u]=o[d][u]}else{let u=o[d].constructor.name;u.includes("Set")?c[d]=Array.from(o[d]):u!=="Number"&&u!=="String"&&u!=="Boolean"?c[d]="instanceof_"+u:c[d]=o[d]}a=c}else a=o}else a=o;return a}return function(o,a){e.push(o);let f=JSON.stringify(o,r,a);return n(),f}}();JSON.stringifyFast===void 0&&(JSON.stringifyFast=Q);var L=class extends b{name=`service${Math.floor(Math.random()*1e15)}`;restrict;constructor(e){super({...e,loaders:e?.loaders?Object.assign({...F},e.loaders):{...F}}),e?.services&&this.addServices(e.services),e?.restrict&&(this.restrict=e.restrict),this.load(this)}addServices=e=>{for(let t in e)if(typeof e[t]=="function"&&(e[t]=new e[t]),e[t]?.__node?.loaders&&Object.assign(this.__node.loaders,e[t].__node.loaders),e[t]?.__node?.nodes){e[t].__node.nodes.forEach((r,_)=>{this.get(_)?this.set(t+"."+_,r):this.set(_,r)}),this.__node.nodes.forEach((r,_)=>{e[t].__node.nodes.get(_)||e[t].__node.nodes.set(_,r)});let n=this.set;this.set=(r,_)=>(e[t].set(r,_),n(r,_));let s=this.delete;this.delete=r=>(e[t].delete(r),s(r))}else typeof e[t]=="object"&&this.load(e[t])};handleMethod=(e,t,n)=>{let s=t,r=this.__node.nodes.get(e);if(r||(r=this.__node.roots[e]),r?.[s])if(typeof r[s]!="function"){if(n){Array.isArray(n)&&n.length===1?r[s]=n[0]:r[s]=n;return}return r[s]}else return Array.isArray(n)?r[s](...n):r[s](n);else return this.handleServiceMessage({route:e,args:n,method:t})};handleServiceMessage(e){let t;return typeof e=="object"&&(e.route?t=e.route:e.node&&(t=e.node)),t?Array.isArray(e.args)?this.run(t,...e.args):this.run(t,e.args):e}handleGraphNodeCall(e,t){if(!e)return t;if(t?.args)this.handleServiceMessage(t);else return Array.isArray(t)?this.run(e,...t):this.run(e,t)}transmit=(...e)=>{if(typeof e[0]=="object"){let t=e[0];if(t.method)return this.handleMethod(t.route,t.method,t.args);if(t.route)return this.handleServiceMessage(t);if(t.node)return this.handleGraphNodeCall(t.node,t.args);this.__node.keepState&&(t.route&&this.setState({[t.route]:t.args}),t.node&&this.setState({[t.node]:t.args}));return}else return};receive=(...e)=>{if(e[0]){let t=e[0];if(typeof t=="string"){let n=t.substring(0,8);(n.includes("{")||n.includes("["))&&(n.includes("\\")&&(t=t.replace(/\\/g,"")),t[0]==='"'&&(t=t.substring(1,t.length-1)),t=JSON.parse(t))}if(typeof t=="object"){if(t.method)return this.restrict?.[t.route]?void 0:this.handleMethod(t.route,t.method,t.args);if(t.route)return this.restrict?.[t.route]?void 0:this.handleServiceMessage(t);if(t.node)return typeof t.node=="string"&&this.restrict?.[t.node]?void 0:this.handleGraphNodeCall(t.node,t.args);this.__node.keepState&&(t.route&&this.setState({[t.route]:t.args}),t.node&&this.setState({[t.node]:t.args}));return}}};pipe=(e,t,n,s,r)=>{if(e instanceof y)return r?this.subscribe(e,_=>{let o=r(_);o!==void 0?this.transmit({route:t,args:o,method:s}):this.transmit({route:t,args:_,method:s},n)}):this.subscribe(e,_=>{this.transmit({route:t,args:_,method:s},n)});if(typeof e=="string")return this.subscribe(e,_=>{this.transmit({route:t,args:_,method:s},n)})};pipeOnce=(e,t,n,s,r)=>{if(e instanceof y)return r?e.__node.state.subscribeEventOnce(e.__node.unique,_=>{let o=r(_);o!==void 0?this.transmit({route:t,args:o,method:s}):this.transmit({route:t,args:_,method:s},n)}):this.__node.state.subscribeEventOnce(e.__node.unique,_=>{this.transmit({route:t,args:_,method:s},n)});if(typeof e=="string")return this.__node.state.subscribeEventOnce(this.__node.nodes.get(e).__node.unique,_=>{this.transmit({route:t,args:_,method:s},n)})};terminate=(...e)=>{};isTypedArray=X;recursivelyAssign=M;spliceTypedArray=Y;ping=()=>(console.log("pinged!"),"pong");echo=(...e)=>(this.transmit(...e),e);log=(...e)=>(console.log(...e),true);error=(...e)=>(console.error(...e),true)};function X(i3){return ArrayBuffer.isView(i3)&&Object.prototype.toString.call(i3)!=="[object DataView]"}var M=(i3,e)=>{for(let t in e)e[t]?.constructor.name==="Object"&&!Array.isArray(e[t])?i3[t]?.constructor.name==="Object"&&!Array.isArray(i3[t])?M(i3[t],e[t]):i3[t]=M({},e[t]):i3[t]=e[t];return i3};function Y(i3,e,t){let n=i3.subarray(0,e),s;t&&(s=i3.subarray(t+1));let r;return(n.length>0||s?.length>0)&&(r=new i3.constructor(n.length+s.length)),r&&(n.length>0&&r.set(n),s&&s.length>0&&r.set(s,n.length)),r}var randomId=prefix=>(prefix?`${prefix}`:"")+Math.floor(1e15*Math.random());var pseudoObjectId=(m=Math,d=Date,h=16,s=s2=>m.floor(s2).toString(h))=>s(d.now()/1e3)+" ".repeat(h).replace(/./g,()=>s(m.random()*h));var StructFrontend=class extends L{name="structs";currentUser;tablet=new DataTablet;collections=this.tablet.collections;id=randomId();useAccessTokens=false;useRefreshTokens=false;constructor(options,user){super(options);this.load(this);if(options.useAccessTokens)this.useAccessTokens=options.useAccessTokens;if(options.useRefreshTokens)this.useRefreshTokens=options.useRefreshTokens;if(user instanceof Object&&Object.keys(user).length>0)this.setupUser(user)}getToken(user){if(this.useAccessTokens)return user.accessToken;else if(this.useRefreshTokens)return user.refreshToken}setupUser=async(userinfo,callback=currentUser=>{})=>{if(!userinfo){console.error('must provide a minimum info object! e.g. {_id:"abc123"}');callback(void 0);return void 0}let changed=false;if(userinfo.id&&!userinfo._id)userinfo._id=userinfo.id;else if(userinfo._id)userinfo.id=userinfo._id;let res=await this.getUser(userinfo._id);let user=res?.user;let u;let newu=false;if(!user||!user._id){u=this.userStruct(userinfo,false);newu=true;let wasSet=await this.setUser(u);let structs=this.getLocalData(void 0,{"ownerId":u._id});if(structs?.length>0)this.updateServerData(structs);this.setAuthorizationsByGroup(u)}else{u=user;let toUpdate={_id:userinfo._id,ownerId:userinfo._id};let struct=this.userStruct(userinfo,false);for(const key in struct){if(userinfo[key]&&user[key]!==userinfo[key]){toUpdate[key]=userinfo[key];user[key]=userinfo[key]}else if(struct[key]&&!user[key]){toUpdate[key]=struct[key];user[key]=struct[key]}}if(Object.keys(toUpdate).length>2)await this.setUser(toUpdate);if(res?.authorizations){if(Array.isArray(res.authorizations)){this.setLocalData(res.authorizations)}}if(res?.groups){if(Array.isArray(res.groups)){this.setLocalData(res.groups)}}}if(newu){this.setLocalData(u)}else{let data=await this.getAllUserData(u._id,void 0,[genTimestampFromString("last day"),Date.now()]);if(!data||data.length===0){}else{this.setLocalData(data);let notes=data.filter(s=>{if(s.structType==="notification"){if(this.getLocalData("authorization",s.parent._id)){return true}if(s.parent.structType==="user"||s.parent.structType==="authorization"){return true}if(!this.getLocalData(s.parent.structType,s.parent._id))return true}});let comments=data.filter(s=>{if(s.structType==="comment"){return true}});let toDelete=[];comments.forEach(comment=>{if(!this.getLocalData("comment",{"_id":comment._id}))toDelete.push(comment._id)});if(toDelete.length>0)this.deleteData(toDelete);if(notes.length>0){this.resolveNotifications(notes,false,void 0);changed=true}let filtered=data.filter(o=>{if(o.structType!=="notification")return true});if(this.tablet)this.tablet.sortStructsIntoTable(filtered)}this.setLocalData(u)}if(u){if(this.currentUser)Object.assign(this.currentUser,u);else this.currentUser=u;callback(this.currentUser);return this.currentUser}else{callback(u);return u}};baseServerCallback=async data=>{let structs=data;if(typeof data==="object"&&data?.structType)structs=[data];if(Array.isArray(structs)){let filtered=structs.filter(o=>{if(o.structType!=="notification")return true});if(this.tablet)this.tablet.sortStructsIntoTable(filtered);for(let i3=0;i3<structs.length;i3++){const struct=structs[i3];if(typeof struct==="object"){if(!struct.structType||struct.structType==="USER"){if(struct.email)struct.structType="user";else struct.structType="uncategorized"}if(struct.structType==="user"||struct.structType==="authorization"||struct.structType==="group"){if(struct.structType==="user"){struct._id=struct.id}else if(struct.structType==="group"){if(this.currentUser){let uset=false;if(struct.admins[this.currentUser?._id]&&!this.currentUser.userRoles?.[struct.name+"_admin"]){this.currentUser.userRoles[struct.name+"_admin"]=true;uset=true}else if(!struct.admins[this.currentUser?._id]&&this.currentUser.userRoles?.[struct.name+"_admin"]){delete this.currentUser.userRoles[struct.name+"_admin"];uset=true}if(struct.admins[this.currentUser?._id]&&!this.currentUser.userRoles?.[struct.name+"_peer"]){this.currentUser.userRoles[struct.name+"_peer"]=true;uset=true}else if(!struct.admins[this.currentUser?._id]&&this.currentUser.userRoles?.[struct.name+"_peer"]){delete this.currentUser.userRoles[struct.name+"_peer"];uset=true}if(struct.admins[this.currentUser?._id]&&!this.currentUser.userRoles?.[struct.name+"_client"]){this.currentUser.userRoles[struct.name+"_client"]=true;uset=true}else if(!struct.admins[this.currentUser?._id]&&this.currentUser.userRoles?.[struct.name+"_client"]){delete this.currentUser.userRoles[struct.name+"_client"];uset=true}if(uset)await this.setUser(this.currentUser)}}this.setLocalData(struct)}else{if(struct.structType==="notification"){let found=this.getLocalData("notification",{"ownerId":struct.ownerId,"_id":struct.parent._id});if(found){this.setLocalData(struct)}else{if(this.getLocalData(struct.structType,{"_id":struct.parent._id})){}else{this.overwriteLocalData(struct)}}if(struct.ownerId===this.currentUser?._id&&(struct.parent.structType==="user"||struct.parent.structType==="dataInstance"||struct.parent.structType==="schedule"||struct.parent.structType==="authorization")){await this.resolveNotifications([struct],true)}this.onNotify(struct)}else{this.overwriteLocalData(struct)}}}}}this.onData(data)};structNotification=()=>{this.checkForNotifications()};structDeleted=struct=>{this.deleteLocalData([struct])};onData=data=>{};onNotify=notification=>{};randomId(tag=""){return`${tag+Math.floor(Math.random()+Math.random()*Math.random()*1e16)}`}addStruct=async(structType="struct",props={},parentUser,parentStruct,updateServer=true)=>{let newStruct=DataStructures_exports.Struct(structType,props,parentUser,parentStruct);if(updateServer)newStruct=await this.updateServerData([newStruct])[0];return newStruct};getUser=async(info="",basicInfo,callback=this.baseServerCallback)=>{console.log(this.currentUser);if(this.currentUser?.request){let res=await this.currentUser.request({route:"getUser",args:[this.currentUser._id,info,basicInfo,this.getToken(this.currentUser)]});callback(res);return res}};queryUsers=async(info,skip,limit,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"queryUsers",args:[this.currentUser._id,info,skip,limit,void 0,this.getToken(this.currentUser)]});callback(res);return res}};getUsers=async(ids=[],basicInfo,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getUsersByIds",args:[this.currentUser._id,ids,basicInfo]});callback(res);return res}};getUsersByRole=async(userRole,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getUsersByRole",args:[this.currentUser._id,userRole]});callback(res);return res}};getAllUserData=async(ownerId,excluded=[],timeRange,callback=this.baseServerCallback)=>{if(timeRange){if(typeof timeRange[0]==="string")timeRange[0]=genTimestampFromString(timeRange[0]);if(typeof timeRange[1]==="string")timeRange[1]=genTimestampFromString(timeRange[1])}if(this.currentUser?.request){let res=await this.currentUser.request({route:"getAllData",args:[this.currentUser._id,ownerId,excluded,timeRange,this.getToken(this.currentUser)]});callback(res);return res}};query=async(collection,mongoQuery={},findOne=false,skip=0,callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(!collection||!mongoQuery)return void 0;let res=await this.currentUser.request({route:"query",args:[this.currentUser._id,collection,mongoQuery,findOne,skip,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};getDataByTimeRange(collection,timeRange,ownerId,limit=0,skip=0,key){let query={};if(timeRange){if(typeof timeRange[0]==="string")timeRange[0]=genTimestampFromString(timeRange[0]);if(typeof timeRange[1]==="string")timeRange[1]=genTimestampFromString(timeRange[1])}let range={$gt:timeRange[0],$lt:timeRange[1]};if(key)query[key]=range;else query.timestamp=range;return this.getData(collection,ownerId,query,limit,skip)}getData=async(collection,ownerId,searchDict,limit=0,skip=0,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getData",args:[this.currentUser._id,collection,ownerId,searchDict,limit,skip,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};getDataByIds=async(structIds=[],ownerId,collection,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getDataByIds",args:[this.currentUser._id,structIds,ownerId,collection,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};getStructParentData=async(struct,callback=this.baseServerCallback)=>{if(!struct?.parent)return;if(this.currentUser?.request){let args=[this.currentUser._id,struct.parent?.structType,"_id",struct.parent?._id,this.getToken(this.currentUser)];let res=(await this.currentUser.request({route:"getData",args}))?.[0];if(typeof callback==="function")callback(res);return res}};setUser=async(userStruct,callback=this.baseServerCallback)=>{if(userStruct&&this.currentUser?.request){let res=await this.currentUser.request({route:"setUser",args:[this.currentUser._id,this.stripStruct(userStruct),this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};checkUserToken=async(usertoken,user=this.currentUser,callback=this.baseServerCallback)=>{if(!usertoken)return false;let changed=false;for(const prop in usertoken){let dummystruct=this.userStruct();if(user[prop]&&prop!=="_id"){if(Array.isArray(usertoken[prop])){for(let i3=0;i3<user[prop].length;i3++){if(usertoken[prop].indexOf(user[prop][i3])<0){user[prop]=usertoken[prop];changed=true;break}}if(!changed)for(let i3=0;i3<usertoken[prop].length;i3++){if(user[prop].indexOf(usertoken[prop][i3])<0){user[prop]=usertoken[prop];changed=true;break}}}else if(user[prop]!==usertoken[prop]){user[prop]=usertoken[prop];changed=true}}else if(!user[prop]&&dummystruct[prop]){user[prop]=usertoken[prop];changed=true}}if(changed)return await this.setUser(user,callback);return changed};setData=async(structs=[],notify=true,callback=this.baseServerCallback)=>{if(this.currentUser?.request){const copies=new Array;if(!Array.isArray(structs)&&typeof structs==="object")structs=[structs];structs.forEach(struct=>{copies.push(this.stripStruct(struct))});let res=await this.currentUser.request({route:"setData",args:[this.currentUser._id,copies,notify,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};updateServerData=this.setData;deleteData=async(structs=[],callback=this.baseServerCallback)=>{if(this.currentUser?.request){let toDelete=[];structs.forEach(struct=>{if(typeof struct==="object"){if(struct?.structType&&struct?._id){toDelete.push({structType:struct.structType,_id:struct._id});this.deleteLocalData(struct)}}else if(typeof struct==="string"){let localstruct=this.getLocalData(void 0,{_id:struct});if(localstruct&&!Array.isArray(localstruct)){toDelete.push({structType:localstruct.structType,_id:localstruct._id})}else{toDelete.push({_id:struct})}}});let res=await this.currentUser.request({route:"deleteData",args:[this.currentUser._id,toDelete,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};deleteUser=async(userId=this.currentUser._id,deleteData,callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(!userId)return;let res=await this.currentUser.request({route:"deleteUser",args:[this.currentUser._id,userId,deleteData,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};setGroup=async(groupStruct,callback=this.baseServerCallback)=>{if(groupStruct&&this.currentUser?.request){let res=await this.currentUser.request({route:"setGroup",args:[this.currentUser._id,this.stripStruct(groupStruct),this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};getUserGroups=async(userId=this.currentUser._id,groupId="",callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getUserGroups",args:[this.currentUser._id,userId,groupId,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};deleteGroup=async(groupId,callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(!groupId)return;this.deleteLocalData(groupId);let res=await this.currentUser.request({route:"deleteGroup",args:[this.currentUser._id,groupId,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};setAuthorization=async(authorizationStruct,callback=this.baseServerCallback)=>{if(authorizationStruct&&this.currentUser?.request){let res=await this.currentUser.request({route:"setAuthorization",args:[this.currentUser._id,this.stripStruct(authorizationStruct),this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};getAuthorizations=async(userId=this.currentUser?._id,authorizationId="",callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(userId===void 0)return;let res=await this.currentUser.request({route:"getAuthorizations",args:[this.currentUser._id,userId,authorizationId,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};deleteAuthorization=async(authorizationId,callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(!authorizationId)return;this.deleteLocalData(authorizationId);let res=await this.currentUser.request({route:"deleteAuthorization",args:[this.currentUser._id,authorizationId,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};checkForNotifications=async(userId=this.currentUser?._id)=>{return await this.getData("notification",userId)};resolveNotifications=async(notifications=[],pull=true,user=this.currentUser)=>{if(!user||notifications.length===0)return;let structIds=[];let notificationIds=[];let nTypes=[];let unote=false;if(notifications.length===0)notifications=this.getLocalData("notification",{"ownerId":user._id});notifications.forEach(struct=>{if(struct.parent.structType==="user")unote=true;nTypes.push(struct.parent.structType);structIds.push(struct.parent._id);notificationIds.push(struct._id);this.deleteLocalData(struct)});this.deleteData(notifications);if(pull){nTypes.reverse().forEach((note,i3)=>{if(note==="user"){this.getUser(structIds[i3]);structIds.splice(structIds.length-i3-1,1)}});if(structIds.length===1)return await this.getDataByIds(structIds,void 0,notifications[0].parent.structType);if(structIds.length>0)return await this.getDataByIds(structIds)}return true};setAuthorizationsByGroup=async(user=this.currentUser)=>{let auths=this.getLocalData("authorization",{"ownerId":user._id});let newauths=[];if(user.userRoles)await Promise.all(Object.keys(user.userRoles).map(async role=>{let split=role.split("_");let team=split[0];let otherrole;if(role.includes("client")){otherrole=team+"_peer"}else if(role.includes("peer")){otherrole=team+"_client"}else if(role.includes("admin")){otherrole=team+"_owner"}if(otherrole){let users=await this.getUsersByRole(otherrole);if(users)await Promise.all(users.map(async groupie=>{let theirname=groupie.username;if(!theirname)theirname=groupie.email;if(!theirname)theirname=groupie._id;let myname=user.username;if(!myname)myname=user.email;if(!myname)myname=user._id;if(theirname!==myname){if(role.includes("client")){let found=auths.find(a=>{if(a.authorizerId===groupie._id&&a.authorizedId===user._id)return true});if(!found){let auth=await this.authorizeUser(DataStructures_exports.ProfileStruct("user",user,user),groupie._id,theirname,user._id,myname,{"peer":true},void 0,{group:team});newauths.push(auth)}}else if(role.includes("peer")){let found=auths.find(a=>{if(a.authorizedId===groupie._id&&a.authorizerId===user._id)return true});if(!found){let auth=await this.authorizeUser(DataStructures_exports.ProfileStruct("user",user,user),user._id,myname,groupie._id,theirname,{"peer":true},void 0,{group:team});newauths.push(auth)}}}}))}}));if(newauths.length>0)return newauths;return void 0};deleteRoom=async roomStruct=>{if(!roomStruct)return false;let toDelete=[roomStruct];roomStruct.comments?.forEach(id=>{let struct=this.getLocalData("comment",{"_id":id});toDelete.push(struct)});if(roomStruct)return await this.deleteData(toDelete);else return false};deleteComment=async commentStruct=>{let allReplies=[commentStruct];let getRepliesRecursive=(head=commentStruct)=>{if(head?.replies){head.replies.forEach(replyId=>{let reply=this.getLocalData("comment",{"_id":replyId});if(reply){if(reply.replies.length>0){reply.replies.forEach(replyId2=>{getRepliesRecursive(replyId2)})}allReplies.push(reply)}})}};getRepliesRecursive(commentStruct);let parent=this.getLocalData(commentStruct.parent?.structType,{"_id":commentStruct.parent?._id});let toUpdate=[];if(parent){toUpdate=[parent];allReplies.forEach(r=>{let idx=parent.replies?.indexOf(r._id);if(idx>-1)parent.replies.splice(idx,1);let idx2=parent.comments?.indexOf(r._id);if(idx2>-1)parent.comments.splice(idx2,1)})}let replyTo=this.getLocalData("comment",{"_id":commentStruct.replyTo});if(replyTo?._id!==parent?._id){let idx=replyTo.replies?.indexOf(parent._id);if(idx>-1)replyTo.replies.splice(idx,1);toUpdate.push(replyTo)}if(toUpdate.length>0)await this.updateServerData(toUpdate);return await this.deleteData(allReplies)};getUserDataByAuthorization=async(authorizationStruct,collection,searchDict,limit=0,skip=0,callback=this.baseServerCallback)=>{let u=authorizationStruct.authorizerId;if(u){return new Promise(async resolve=>{this.getUser(u,true,async data=>{let res;if(!collection)res=await this.getAllUserData(u,["notification"],void 0,callback);else res=await this.getData(collection,u,searchDict,limit,skip,callback);resolve(res);callback(res)})})}else return void 0};getUserDataByAuthorizationGroup=async(groupId="",collection,searchDict,limit=0,skip=0,callback=this.baseServerCallback)=>{let auths=this.getLocalData("authorization");let results=[];await Promise.all(auths.map(async o=>{if(o.groups?.includes(groupId)){let u=o.authorizerId;if(u){let data;let user=await this.getUser(u,true,callback);if(user)results.push(user);if(!collection)data=await this.getAllUserData(u,["notification"],void 0,callback);else data=await this.getData(collection,u,searchDict,limit,skip,callback);if(data)results.push(data)}return true}}));return results};overwriteLocalData(structs){if(Array.isArray(structs)){structs.forEach(struct=>{let localdat=this.getLocalData(struct.structType,{"ownerId":struct.ownerId,"_id":struct._id});if(!localdat||localdat?.length===0){this.setLocalData(struct)}else Object.assign(localdat,struct)})}else{let localdat=this.getLocalData(structs.structType,{"ownerId":structs.ownerId,"_id":structs._id});if(!localdat||localdat?.length===0){this.setLocalData(structs)}else Object.assign(localdat,structs)}}setLocalData(structs){this.tablet.setLocalData(structs)}getLocalData(collection,query){return this.tablet.getLocalData(collection,query)}getLocalUserPeerIds=(user=this.currentUser)=>{if(!user)return{};let result={};let authorizations=this.getLocalData("authorization",user._id);authorizations.forEach(a=>{if(a.authorizations["peer"]&&a.authorizerId===user._id)result[a.authorizedId]=true});return result};getLocalReplies(struct){let replies=[];if(!struct.replies)return replies;else if(struct.replies.reduce((a,b2)=>a*(typeof b2==="object"?1:0),1))return struct.replies;replies=this.getLocalData("comment",{"replyTo":struct._id});return replies}hasLocalAuthorization(otherUserId,ownerId=this.currentUser._id){let auths=this.getLocalData("authorization",{ownerId});let found=auths.find(a=>{if(a.authorizedId===ownerId&&a.authorizerId===otherUserId)return true;if(a.authorizerId===ownerId&&a.authorizedId===otherUserId)return true});if(found){return found}else return false}deleteLocalData(structs){if(Array.isArray(structs))structs.forEach(s=>this.deleteStruct(s));else this.deleteStruct(structs);return true}deleteStruct(struct){if(typeof struct==="string")struct=this.getLocalData(void 0,{_id:struct});if(!struct)throw new Error("Struct not supplied");if(!struct.structType||!struct._id)return false;this.tablet.collections.get(struct.structType).delete(struct._id);return true}stripStruct(struct){const copy=Object.assign({},struct);for(const prop in copy){if(copy[prop]===void 0||copy[prop]===""||copy[prop].constructor.name==="Map"||copy[prop].constructor.name==="Set"||typeof copy[prop]==="function")delete copy[prop];else if(Array.isArray(copy[prop])&&copy[prop].length===0)delete copy[prop];else if(typeof copy[prop]==="object"&&Object.keys(copy[prop]).length===0)delete copy[prop]}return copy}createStruct(structType,props,parentUser=this.currentUser,parentStruct){let struct=DataStructures_exports.Struct(structType,props,parentUser,parentStruct);return struct}userStruct(props={},currentUser=false){let user=DataStructures_exports.ProfileStruct(void 0,props,props);if(!user.name&&user.firstName)user.name=user.firstName+" "+user.lastName;else if(user.name&&!user.firstName){let split=user.name.split(" ");user.firstName=split[0];user.lastName=split[split.length-1]}if(props._id)user.id=props._id;else if(props.id)user.id=props.id;else user.id="user"+Math.floor(Math.random()*1e15);user._id=user.id;user.ownerId=user.id;let dummy=DataStructures_exports.ProfileStruct();for(const prop in props){if(Object.keys(dummy).indexOf(prop)<0){delete user[prop]}}if(currentUser)this.currentUser=user;return user}authorizeUser=async(parentUser,authorizerUserId="",authorizerUserName="",authorizedUserId="",authorizedUserName="",authorizations={},structs={},excluded={},groups={},expires=false)=>{if(!parentUser)return void 0;let newAuthorization=this.createStruct("authorization",void 0,parentUser,void 0);newAuthorization.authorizedId=authorizedUserId;newAuthorization.authorizedName=authorizedUserName;newAuthorization.authorizerId=authorizerUserId;newAuthorization.authorizerName=authorizerUserName;newAuthorization.authorizations=authorizations;newAuthorization.structs=structs;newAuthorization.excluded=excluded;newAuthorization.groups=groups;newAuthorization.expires=expires;newAuthorization.status="PENDING";newAuthorization.associatedAuthId="";newAuthorization=await this.setAuthorization(newAuthorization);return newAuthorization};addGroup=async(parentUser,name="",details="",admins={},peers={},clients={},updateServer=true)=>{if(!parentUser)return void 0;let newGroup=this.createStruct("group",void 0,parentUser);newGroup.name=name;newGroup.details=details;newGroup.admins=admins;newGroup.peers=peers;newGroup.clients=clients;newGroup.users={};Object.assign(newGroup.users,newGroup.admins);Object.assign(newGroup.users,newGroup.peers);Object.assign(newGroup.users,newGroup.clients);if(updateServer){newGroup=await this.setGroup(newGroup)}return newGroup};dataObject(data=void 0,type="any",timestamp=Date.now()){return{type,data,timestamp}}addData=async(parentUser,author="",title="",type="",data=[],expires=false,updateServer=true)=>{if(!parentUser)return void 0;let newDataInstance=this.createStruct("dataInstance",void 0,parentUser);newDataInstance.author=author;newDataInstance.title=title;newDataInstance.type=type;newDataInstance.data=data;newDataInstance.expires=expires;if(updateServer)newDataInstance=await this.updateServerData([newDataInstance])[0];return newDataInstance};addEvent=async(parentUser,author="",event="",notes="",startTime,endTime,grade,value,units,location,attachments,users,updateServer=true)=>{if(!parentUser)return void 0;if(users&&Object.keys(users).length===0)users=this.getLocalUserPeerIds(parentUser);let newEvent=this.createStruct("event",void 0,parentUser);newEvent.author=author;newEvent.event=event;newEvent.notes=notes;newEvent.startTime=startTime;newEvent.endTime=endTime;newEvent.grade=grade;newEvent.attachments=attachments;newEvent.value=value;newEvent.units=units;newEvent.users=users;newEvent.location=location;if(updateServer)newEvent=await this.updateServerData([newEvent])[0];return newEvent};addChatroom=async(parentUser,authorId="",message="",attachments,users,updateServer=true)=>{if(!parentUser)return void 0;if(users&&Object.keys(users).length===0)users=this.getLocalUserPeerIds(parentUser);let newChatroom=this.createStruct("chatroom",void 0,parentUser);newChatroom.message=message;newChatroom.attachments=attachments;newChatroom.authorId=authorId;newChatroom.users=users;newChatroom.replies=[];newChatroom.comments=[];let update=[newChatroom];if(updateServer)newChatroom=await this.updateServerData(update)[0];return newChatroom};addComment=async(parentUser,roomStruct,replyTo,authorId="",message="",attachments,updateServer=true)=>{if(!roomStruct)return void 0;if(!replyTo)replyTo=roomStruct;if(!parentUser)return void 0;let newComment=this.createStruct("comment",void 0,parentUser,roomStruct);newComment.authorId=authorId;newComment.replyTo=replyTo?._id;newComment.message=message;newComment.attachments=attachments;newComment.users=roomStruct?.users;newComment.replies=[];if(!updateServer)replyTo?.replies.push(newComment._id);if(!updateServer)roomStruct?.comments.push(newComment._id);let update=[newComment,roomStruct];if(replyTo?._id!==roomStruct._id)update.push(replyTo);let res;if(updateServer)res=await this.updateServerData(update);let updatedComment;if(typeof res==="object"){updatedComment=res.find(s=>{if(newComment.ownerId===s.ownerId&&newComment.timestamp===s.timestamp&&newComment.message===s.message){return true}})}if(updatedComment)return updatedComment;return res}};var MACHINE_ID=Math.floor(Math.random()*16777215);var index=ObjectId.index=parseInt(Math.random()*16777215,10);var pid=(typeof process==="undefined"||typeof process.pid!=="number"?Math.floor(Math.random()*1e5):process.pid)%65535;var BufferCtr=(()=>{try{return _Buffer}catch(_){try{return Buffer}catch(_2){return null}}})();var isBuffer=function(obj){return!!(obj!=null&&obj.constructor&&typeof obj.constructor.isBuffer==="function"&&obj.constructor.isBuffer(obj))};var hexTable=[];for(i3=0;i3<256;i3++){hexTable[i3]=(i3<=15?"0":"")+i3.toString(16)}var i3;var checkForHexRegExp=new RegExp("^[0-9a-fA-F]{24}$");var decodeLookup=[];i3=0;while(i3<10)decodeLookup[48+i3]=i3++;while(i3<16)decodeLookup[65-10+i3]=decodeLookup[97-10+i3]=i3++;function ObjectId(id){if(!(this instanceof ObjectId))return new ObjectId(id);if(id&&(id instanceof ObjectId||id._bsontype==="ObjectId"))return id;this._bsontype="ObjectId";if(id==null||typeof id==="number"){this.id=this.generate(id);return}var valid=ObjectId.isValid(id);if(!valid&&id!=null){throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters")}else if(valid&&typeof id==="string"&&id.length===24){return ObjectId.createFromHexString(id)}else if(id!=null&&id.length===12){this.id=id}else if(id!=null&&typeof id.toHexString==="function"){return id}else{throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters")}}ObjectId.createFromTime=function(time){time=parseInt(time,10)%4294967295;return new ObjectId(hex(8,time)+"0000000000000000")};ObjectId.createFromHexString=function(hexString){if(typeof hexString==="undefined"||hexString!=null&&hexString.length!==24){throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters")}var data="";var i3=0;while(i3<24){data+=String.fromCharCode(decodeLookup[hexString.charCodeAt(i3++)]<<4|decodeLookup[hexString.charCodeAt(i3++)])}return new ObjectId(data)};ObjectId.isValid=function(id){if(id==null)return false;if(typeof id==="number"){return true}if(typeof id==="string"){return id.length===12||id.length===24&&checkForHexRegExp.test(id)}if(id instanceof ObjectId){return true}if(isBuffer(id)){return ObjectId.isValid(id.toString("hex"))}if(typeof id.toHexString==="function"){if(BufferCtr&&(id.id instanceof BufferCtr||typeof id.id==="string")){return id.id.length===12||id.id.length===24&&checkForHexRegExp.test(id.id)}}return false};ObjectId.prototype={constructor:ObjectId,toHexString:function(){if(!this.id||!this.id.length){throw new Error("invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is ["+JSON.stringify(this.id)+"]")}if(this.id.length===24){return this.id}if(isBuffer(this.id)){return this.id.toString("hex")}var hexString="";for(var i3=0;i3<this.id.length;i3++){hexString+=hexTable[this.id.charCodeAt(i3)]}return hexString},equals:function(otherId){if(otherId instanceof ObjectId){return this.toString()===otherId.toString()}else if(typeof otherId==="string"&&ObjectId.isValid(otherId)&&otherId.length===12&&isBuffer(this.id)){return otherId===this.id.toString("binary")}else if(typeof otherId==="string"&&ObjectId.isValid(otherId)&&otherId.length===24){return otherId.toLowerCase()===this.toHexString()}else if(typeof otherId==="string"&&ObjectId.isValid(otherId)&&otherId.length===12){return otherId===this.id}else if(otherId!=null&&(otherId instanceof ObjectId||otherId.toHexString)){return otherId.toHexString()===this.toHexString()}else{return false}},getTimestamp:function(){var timestamp=new Date;var time;if(isBuffer(this.id)){time=this.id[3]|this.id[2]<<8|this.id[1]<<16|this.id[0]<<24}else{time=this.id.charCodeAt(3)|this.id.charCodeAt(2)<<8|this.id.charCodeAt(1)<<16|this.id.charCodeAt(0)<<24}timestamp.setTime(Math.floor(time)*1e3);return timestamp},generate:function(time){if("number"!==typeof time){time=~~(Date.now()/1e3)}time=parseInt(time,10)%4294967295;var inc=next();return String.fromCharCode(time>>24&255,time>>16&255,time>>8&255,time&255,MACHINE_ID>>16&255,MACHINE_ID>>8&255,MACHINE_ID&255,pid>>8&255,pid&255,inc>>16&255,inc>>8&255,inc&255)}};function next(){return index=(index+1)%16777215}function hex(length,n){n=n.toString(16);return n.length===length?n:"00000000".substring(n.length,length)+n}var inspect=Symbol&&Symbol.for&&Symbol.for("nodejs.util.inspect.custom")||"inspect";ObjectId.prototype[inspect]=function(){return"ObjectId("+this+")"};ObjectId.prototype.toJSON=ObjectId.prototype.toHexString;ObjectId.prototype.toString=ObjectId.prototype.toHexString;var randomId2=prefix=>(prefix?`${prefix}_`:"")+Math.floor(1e15*Math.random());var toObjectId=str=>{return typeof str==="string"&&str.length===24?new ObjectId(str):str};var getStringId=mongoid=>{if(typeof mongoid==="object")return mongoid.toString();else return mongoid};var defaultCollections=["profile","group","authorization","discussion","chatroom","comment","dataInstance","event","notification","schedule","date"];var StructBackend=class extends L{name="structs";debug=false;db;users={};collections={};mode="local";useAuths=true;useAccessTokens=false;useRefreshTokens=false;accessTokens=new Map;refreshTokens=new Map;constructor(options,dboptions){super(options);this.load(this);if(dboptions){this.initDB(dboptions)}}initDB=dboptions=>{this.db=dboptions.db;if(dboptions?.users)this.users=dboptions.users;if(dboptions.mode)this.mode=dboptions.mode;if(dboptions?.collections)this.collections=dboptions.collections;if(dboptions.debug)this.debug=dboptions.debug;if(dboptions.useAccessTokens)this.useAccessTokens=dboptions.useAccessTokens;if(dboptions.useRefreshTokens)this.useRefreshTokens=dboptions.useRefreshTokens;if("useAuths"in dboptions)this.useAuths=dboptions.useAuths;defaultCollections.forEach(k2=>{if(!this.collections[k2]){this.collections[k2]=this.db?{instance:this.db.collection(k2)}:{};this.collections[k2].reference={}}})};query=async(requestingUserId,collection,queryObj,findOne,skip,token)=>{let user=this.users[requestingUserId];if(!user)return false;if(this.mode.indexOf("mongo")>-1){return await this.queryMongo(user,collection,queryObj,findOne,skip,token)}else{let res=this.getLocalData(user,collection);if(res&&!Array.isArray(res)){let passed=!this.useAuths;if(!res?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,res,"READ",token);if(passed)return res}if(typeof skip==="number"&&Array.isArray(res)){if(res.length>skip)res.splice(0,skip)}let data=[];if(res)await Promise.all(res.map(async s=>{let struct=this.getLocalData(getStringId(s._id));let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);if(passed)data.push(struct)}));return data}};getUser=async(requestingUserId,lookupId,basicInfo,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.indexOf("mongo")>-1){data=await this.getMongoUser(user,lookupId,void 0,basicInfo,token)}else{let struct=this.getLocalData("profile",{_id:lookupId});if(!struct)data={user:void 0};else{let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);if(passed){let groups=this.getLocalData("group",{ownerId:lookupId});let auths=this.getLocalData("authorization",{ownerId:lookupId});data={user:struct,groups,authorizations:auths}}else data={user:{}}}}if(this.debug)console.log("getUser: user:",user,"input:",lookupId,"output",data);return data};setUser=async(requestingUserId,struct,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(struct.accessToken){this.accessTokens.set(requestingUserId,token)}else if(this.useAccessTokens)return false;if(struct.refreshToken){this.refreshTokens.set(requestingUserId,struct.refreshToken)}else if(this.useRefreshTokens)return false;delete struct.accessToken;delete struct.refreshToken;delete user.accessToken;delete user.refreshToken;if(this.mode.indexOf("mongo")>-1){data=await this.setMongoUser(user,struct,token)}else{let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(passed)this.setLocalData(struct);return true}if(this.debug)console.log("setUser user:",user,"input:",struct,"output",data);return data};getUsersByIds=async(requestingUserId,userIds,basicInfo)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoUsersByIds(user,userIds,basicInfo)}else{data=[];if(Array.isArray(userIds)){let struct=this.getLocalData("profile",{_id:userIds});if(struct){if(basicInfo)data.push({_id:struct._id,username:struct.username,firstName:struct.firstName,lastName:struct.lastName,fullName:struct.fullName,pictureUrl:struct.pictureUrl});else data.push(struct)}}}if(this.debug)console.log("getUserByIds: user:",user,"input:",userIds,"output",data);return data};getUsersByRole=async(requestingUserId,role)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoUsersByRole(user,role)}else{let profiles=this.getLocalData("profile");data=[];profiles.forEach(struct=>{if(struct.userRoles[role]){data.push(struct)}})}if(this.debug)console.log("getUserByRoles: user:",user,"input:",role,"output",data);return data};deleteUser=async(requestingUserId,userId,deleteData,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.deleteMongoUser(user,userId,deleteData,token)}else{data=false;let struct=this.getLocalData(userId);if(struct){let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(passed)data=this.deleteLocalData(struct)}}if(this.debug)console.log("deleteUser: user:",user,"input:",userId,"output",data);return data};setData=async(requestingUserId,structs,notify,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.setMongoData(user,structs,notify,token)}else{let non_notes=[];data=[];await Promise.all(structs.map(async structId=>{let struct=this.getLocalData(structId);let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(passed){if(!this.collections[struct.structType]){this.collections[struct.structType]={};this.collections[struct.structType].reference={}}this.setLocalData(struct);data.push(struct);if(struct.structType!=="notification")non_notes.push(struct)}}));if(non_notes.length>0&&(notify===true||typeof notify==="undefined"))this.checkToNotify(user,non_notes,this.mode);if(this.debug)console.log("setData:",user,structs,data);return true}if(this.debug)console.log("setData: user:",user,"input:",structs,notify,"output",data);return data};getData=async(requestingUserId,collection,ownerId,dict,limit,skip,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoData(user,collection,ownerId,dict,limit,skip,token)}else{data=[];let structs;if(collection)structs=this.getLocalData(collection);if(structs&&ownerId)structs=structs.filter(o=>{if(o.ownerId===ownerId)return true});if(structs)await Promise.all(structs.map(async s=>{let struct=this.getLocalData(getStringId(s._id));let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);if(passed)data.push(struct)}))}if(this.debug)console.log("getData: user:",user,"input:",collection,ownerId,dict,limit,skip,"output",data);return data};getDataByIds=async(requestingUserId,structIds,ownerId,collection,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoDataByIds(user,structIds,ownerId,collection,token)}else{data=[];let structs;if(collection)structs=this.getLocalData(collection);if(structs&&ownerId)structs=structs.filter(o=>{if(o.ownerId===ownerId)return true});if(structs)await Promise.all(structs.map(async s=>{let struct=this.getLocalData(getStringId(s._id));let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);if(passed)data.push(struct)}))}if(this.debug)console.log("getDataByIds: user:",user,"input:",structIds,ownerId,collection,"output",data);return data};getAllData=async(requestingUserId,ownerId,excludedCollections,timeRange,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getAllUserMongoData(user,ownerId,excludedCollections,timeRange,token)}else{let result=this.getLocalData(void 0,{ownerId});data=[];await Promise.all(result.map(async struct=>{if(excludedCollections){if(excludedCollections.indexOf(struct.structType)<0){let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);if(passed)data.push(struct)}}else{let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);if(passed)data.push(struct)}}))}if(this.debug)console.log("getAllData: user:",user,"input:",ownerId,excludedCollections,"output",data);return data};deleteData=async(requestingUserId,structIds,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.deleteMongoData(user,structIds,token)}else{data=false;await Promise.all(structIds.map(async structId=>{let struct=this.getLocalData(structId);let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(passed)this.deleteLocalData(struct);data=true}))}if(this.debug)console.log("deleteData: user:",user,"input:",structIds,"output",data);return data};getUserGroups=async(requestingUserId,userId,groupId)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoGroups(user,userId,groupId)}else{if(typeof groupId==="string"){data=this.getLocalData("group",{_id:groupId})}else{data=[];let result=this.getLocalData("group");if(userId){result.forEach(struct=>{if(Object.keys(struct.users).includes(userId))data.push(struct)})}else{result.forEach(struct=>{if(Object.keys(struct.users).includes(getStringId(user._id)))data.push(struct)})}}}if(this.debug)console.log("getGroups: user:",user,"input:",userId,groupId,"output",data);return data};deleteGroup=async(requestingUserId,groupId,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.deleteMongoGroup(user,groupId,token)}else{let struct=this.getLocalData("group",groupId);let passed=!this.useAuths;if(struct){if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token)}if(passed){data=true}}if(this.debug)console.log("deleteGroup: user:",user,"input:",groupId,"output",data);return data};getAuthorizations=async(requestingUserId,ownerId,authId,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoAuthorizations(user,ownerId,authId,token)}else{if(authId){let result=this.getLocalData("authorization",{_id:authId});if(result)data=[result]}else{data=this.getLocalData("authorization",{ownerId})}}if(this.debug)console.log("getAuthorizations: user:",user,"input:",ownerId,authId,"output",data);return data};deleteAuthorization=async(requestingUserId,authId,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.deleteMongoAuthorization(user,authId,token)}else{data=true;let struct=this.getLocalData("authorization",{_id:authId});if(struct){let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(passed)data=this.deleteLocalData(struct)}}if(this.debug)console.log("deleteAuthorization: user:",user,"input:",authId,"output",data);return data};getToken=user=>{return this.useAccessTokens?this.accessTokens.get(user._id):this.useRefreshTokens?this.refreshTokens.get(user._id):void 0};notificationStruct=(parentStruct={})=>{let structType="notification";let struct={structType,timestamp:Date.now(),_id:randomId2(structType),note:"",alert:false,ownerId:"",parentUserId:"",parent:{structType:parentStruct?.structType,_id:getStringId(parentStruct?._id)}};return struct};checkToNotify=async(user,structs=[],mode=this.mode)=>{if(structs.length===0)return false;if(typeof user==="string"){for(let key in this.users){const obj=this.users[key];if(getStringId(obj._id)===user)user=obj}}if(typeof user==="string"||user==null)return false;let usersToNotify={};let newNotifications=[];structs.forEach(async struct=>{if(struct?._id){if(struct.ownerId&&user?._id!==struct.ownerId){let newNotification=this.notificationStruct(struct);newNotification._id="notification_"+getStringId(struct._id)+"_"+struct.ownerId;newNotification.ownerId=struct.ownerId;newNotification.note=struct.structType;newNotification.parentUserId=struct.ownerId;if(struct.alert)newNotification.alert=struct.alert;newNotifications.push(newNotification);usersToNotify[struct.ownerId]=struct.ownerId}if(struct.users){Object.keys(struct.users).forEach(usr=>{if(usr!==user._id){let newNotification=this.notificationStruct(struct);newNotification._id="notification_"+getStringId(struct._id)+"_"+usr;newNotification.ownerId=usr;newNotification.note=struct.structType;if(struct.alert)newNotification.alert=struct.alert;newNotification.parentUserId=struct.ownerId;newNotifications.push(newNotification);usersToNotify[usr]=usr}})}else{let auths=[];if(mode.includes("mongo")){let s=this.collections.authorization.instance.find({$or:[{authorizedId:user._id},{authorizerId:user._id}]});let arr=await s.toArray();if(arr.length>0){arr.forEach(d=>auths.push(d))}}else{auths=this.getLocalData("authorization",{authorizedId:user._id});auths.push(...this.getLocalData("authorization",{authorizerId:user._id}))}if(auths.length>0){auths.forEach(auth=>{if(struct.authorizerId===struct.ownerId&&!usersToNotify[struct.authorizedId]){if(auth.status==="OKAY"&&auth.authorizations["peer"]){let newNotification=this.notificationStruct(struct);newNotification.ownerId=auth.authorizedId;newNotification._id="notification_"+getStringId(struct._id)+"_"+auth.authorizedId;newNotification.note=struct.structType;newNotification.parentUserId=struct.ownerId;if(struct.alert)newNotification.alert=struct.alert;newNotifications.push(newNotification);usersToNotify[newNotification.ownerId]=newNotification.ownerId}}})}}}});if(newNotifications.length>0){if(mode.includes("mongo")){await this.setMongoData(user,newNotifications,true,this.getToken(user))}else{this.setLocalData(newNotifications)}for(const uid in usersToNotify){this.users[uid]?.sendAll({route:"structNotification",args:true})}return true}else return false};queryMongo=async(user,collection,queryObj={},findOne=false,skip=0,token)=>{if(!collection&&!queryObj)return void 0;else if(findOne){let res=await this.db.collection(collection).findOne(queryObj);if(!res)return void 0;let passed=!this.useAuths;if(!res?.ownerId){passed=true}else if(getStringId(user._id)!==res.ownerId||getStringId(user._id)===res.ownerId&&user.userRoles?.admincontrol){if(this.useAuths)passed=await this.checkAuthorization(user,res,"READ",token)}if(passed)return res;else return void 0}else{let res=this.db.collection(collection).find(queryObj).sort({$natural:-1}).skip(skip);let structs=[];let arr=await res.toArray();if(arr.length>0){let passed=!this.useAuths;let checkedAuth="";for(const s of arr){if(!s?.ownerId){passed=true}else if((getStringId(user._id)!==s.ownerId||getStringId(user._id)===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s,"READ",token);checkedAuth=s.ownerId}if(passed)structs.push(s)}}return structs}};setMongoData=async(user,structs=[],notify=true,token)=>{let firstwrite=false;if(structs.length>0){let passed=!this.useAuths;let checkedAuth="";await Promise.all(structs.map(async struct=>{let secondary={};if(Array.isArray(struct)){secondary=struct[1];struct=struct[0]}if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if((getStringId(user._id)!==struct.ownerId||getStringId(user._id)===struct.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==struct.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);checkedAuth=struct.ownerId}if(passed){if(struct.structType){if(!this.collections[struct.structType]){this.collections[struct.structType]={};this.collections[struct.structType].reference={}}let copy=JSON.parse(JSON.stringify(struct));if(copy._id)delete copy._id;if(struct._id){if(getStringId(struct._id).includes("defaultId")){await this.db.collection(struct.structType?struct.structType:"data").insertOne(copy);firstwrite=true}else if(struct.structType==="notification")await this.db.collection(struct.structType?struct.structType:"data").updateOne({_id:struct._id},{$set:copy,...secondary},{upsert:true,unique:false});else await this.db.collection(struct.structType?struct.structType:"data").updateOne({_id:toObjectId(struct._id)},{$set:copy,...secondary},{upsert:true})}else if(struct.structType){this.db.collection(struct.structType?struct.structType:"data").insertOne(copy)}}}}));if(firstwrite===true){let toReturn=[];await Promise.all(structs.map(async(struct,j2)=>{let copy=JSON.parse(JSON.stringify(struct));if(copy._id&&copy.structType!=="profile")delete copy._id;if(struct.structType!=="comment"){let pulled;if(struct.structType!=="notification")pulled=await this.db.collection(copy.structType).findOne(copy);if(pulled){pulled._id=getStringId(pulled._id);toReturn.push(pulled)}}else if(struct.structType==="comment"){let comment=struct;let copy2=JSON.parse(JSON.stringify(comment));if(copy2._id)delete copy2._id;let pulledComment=await this.db.collection("comment").findOne(copy2);let replyToId=pulledComment?.replyTo;let replyTo=structs.find(s=>{if(getStringId(s._id)===replyToId)return true});if(replyTo){let copy3=JSON.parse(JSON.stringify(replyTo));if(copy3._id)delete copy3._id;let pulledReply;await Promise.all(["discussion","chatroom","comment"].map(async name=>{let found=await this.db.collection(name).findOne({_id:toObjectId(replyToId)});if(found)pulledReply=found}));if(pulledReply){let roomId=getStringId(pulledComment.parent._id);let room,pulledRoom;if(roomId!==replyToId){room=structs.find(s=>{if(getStringId(s._id)===roomId)return true});if(room){delete room._id;await Promise.all(["discussion","chatroom"].map(async name=>{let found=await this.db.collection(name).findOne(room);if(found)pulledRoom=found}))}}else pulledRoom=pulledReply;let toUpdate=[pulledComment];if(pulledReply){let i3=pulledReply.replies.indexOf(getStringId(pulledComment._id));if(i3<0){pulledReply.replies.push(getStringId(pulledComment._id));pulledComment.replyTo=getStringId(pulledReply._id)}toUpdate.push(pulledReply)}if(pulledRoom){let i3=pulledRoom.comments.indexOf(pulledComment._id);if(i3<0){pulledRoom.comments.push(getStringId(pulledComment._id));pulledComment.parent._id=getStringId(pulledRoom._id)}}await Promise.all(toUpdate.map(async s=>{let copy4=JSON.parse(JSON.stringify(s));delete copy4._id;await this.db.collection(s.structType).updateOne({_id:toObjectId(s._id)},{$set:copy4},{upsert:false})}));[...toReturn].reverse().forEach((s,j3)=>{if(toUpdate.find(o=>{if(getStringId(s._id)===getStringId(o._id))return true})){toReturn.splice(toReturn.length-j3-1,1)}});toReturn.push(...toUpdate)}}else if(pulledComment){toReturn.push(pulledComment)}}}));if(notify)this.checkToNotify(user,toReturn);return toReturn}else{let non_notes=[];structs.forEach(s=>{if(s.structType!=="notification")non_notes.push(s)});if(notify)this.checkToNotify(user,non_notes);return true}}else return false};setMongoUser=async(user,struct,token)=>{if(struct._id){const _id=toObjectId(struct._id);let usersearch={_id};let userexists=await this.collections.profile.instance.findOne(usersearch);if(userexists){if(getStringId(user._id)!==struct.ownerId||getStringId(user._id)===struct.ownerId&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(!passed)return false}}let copy=JSON.parse(JSON.stringify(struct));copy._id=_id;if(this.debug)console.log("RETURNS PROFILE",struct);await this.collections.profile.instance.updateOne(usersearch,{$set:copy},{upsert:true});user=await this.collections.profile.instance.findOne(usersearch);this.checkToNotify(user,[struct]);return user}else return false};setGroup=async(user,struct,mode=this.mode,token)=>{if(struct?._id){let uid=getStringId(user._id);let exists=void 0;if(mode.includes("mongo")){exists=await this.collections.group.instance.findOne({name:struct.name})}else{exists=this.getLocalData("group",{_id:getStringId(struct._id)})}if(exists&&(exists.ownerId!==struct.ownerId||struct.admins.indexOf(uid)<0))return false;if(uid!==struct.ownerId){let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(!passed)return false}let allusers=[];Object.keys(struct.users).forEach(u=>{allusers.push({email:u},{id:u},{username:u})});let users={};let ids={};if(mode.includes("mongo")){let cursor=this.collections.profile.instance.find({$or:allusers});let arr=cursor.toArray();if(arr.length>0){arr.forEach(user2=>{users[uid]=user2;ids[uid]=true})}}else{allusers.forEach(search=>{let result=this.getLocalData("profile",search);if(result.length>0){users[getStringId(result[0]._id)]=result[0];ids[getStringId(result[0]._id)]=true}})}struct.users=ids;let admins={};let peers={};let clients={};Object.keys(users).forEach(id=>{let u=users[id];if(struct.admins[getStringId(u._id)]||struct.admins[u.email]||struct.admins[u.username]||struct.admins[struct.ownerId]){if(!admins[getStringId(u._id)])admins[getStringId(u._id)]=true}if(struct.peers[getStringId(u._id)]||struct.peers[u.email]||struct.peers[u.username]||struct.peers[struct.ownerId]){if(!peers[getStringId(u._id)])peers[getStringId(u._id)]=true}if(struct.clients[getStringId(u._id)]||struct.clients[u.email]||struct.clients[u.username]||struct.clients[struct.ownerId]){if(!clients[getStringId(u._id)])clients[getStringId(u._id)]=true}});struct.admins=admins;struct.peers=peers;struct.clients=clients;let copy=JSON.parse(JSON.stringify(struct));if(copy._id)delete copy._id;if(mode.includes("mongo")){if(getStringId(struct._id).includes("defaultId")){await this.db.collection(struct.structType?struct.structType:"data").insertOne(copy);delete struct._id;struct=await this.db.collection(struct.structType?struct.structType:"data").findOne(struct);struct._id=getStringId(struct._id)}else await this.collections.group.instance.updateOne({_id:toObjectId(struct._id)},{$set:copy},{upsert:true})}else{this.setLocalData(struct)}this.checkToNotify(user,[struct],this.mode);if(this.debug)console.log("setGroup: user:",user,"output",struct);return struct}else return false};getMongoUser=(user,info="",requireAuth=true,basicInfo=false,token)=>{return new Promise(async resolve=>{const query=[{email:info},{id:info},{username:info}];try{query.push({_id:toObjectId(info)})}catch(e){console.log("error creating ObjectId with ",info)}let u=await this.collections.profile.instance.findOne({$or:query});if(!u||u==null)resolve(void 0);else{u._id=getStringId(u._id);if(!u.ownerId)u.ownerId=u._id;if(basicInfo){if(this.useAccessTokens||this.useRefreshTokens){if(this.getToken(user)!==token)resolve(void 0)}let stripped={username:u.username,firstName:u.firstName,lastName:u.lastName,fullName:u.fullName,pictureUrl:u.pictureUrl,_id:u._id};u=stripped;resolve({user:u})}else if(requireAuth){if(getStringId(user._id)!==u._id||getStringId(user._id)===u._id&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,u,"READ",token);if(!passed)resolve(void 0)}let authorizations=[];let auths=this.collections.authorization.instance.find({ownerId:u._id});let aarr=await auths.toArray();if(auths.toArray().length>0){aarr.forEach(d=>authorizations.push(d))}let gs=this.collections.group.instance.find({users:{$all:[u._id]}});let arr=await gs.toArray();let groups=[];if(arr.length>0){arr.forEach(d=>groups.push(d))}resolve({user:u,authorizations,groups})}else{if(this.useAccessTokens||this.useRefreshTokens){if(this.getToken(user)!==token)resolve(void 0)}resolve({user:u})}}})};queryUsers=(user,info="",limit=0,skip=0,requireAuth=false,token)=>{if(typeof user==="string")user=this.users[user];if(!user)return Promise.resolve(void 0);return new Promise(async resolve=>{let q2={$regex:`^${info}`,$options:"i"};const query=[{email:q2},{username:q2},{firstName:q2},{lastName:q2},{name:q2}];let arr;if(this.mode.includes("mongo")){let users=this.collections.profile.instance.find({$or:query},{projection:shallowqueryDummy}).skip(skip);if(limit>0)users.limit(limit);await users;arr=await users.toArray();console.log(arr)}else{arr=[];for(let i3=0;i3<query.length;i3++){let dat=this.getLocalData("profile",query[i3]);if(Array.isArray(dat)){dat.forEach(u=>{arr.push({firstName:u.firstName,lastName:u.lastName,fullName:u.fullName,username:u.username,pictureUrl:u.pictureUrl})})}else if(dat)arr.push({firstName:dat.firstName,lastName:dat.lastName,fullName:dat.fullName,username:dat.username,pictureUrl:dat.pictureUrl})}}if(requireAuth){let result=[];let strid=getStringId(user._id);for(let i3=0;i3<arr.length;i3++){let u=arr[i3];u._id=getStringId(u._id);if(strid!==u._id||strid===u._id&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,u,"READ",token);if(passed)result.push(u)}}arr=result}else if(this.useAccessTokens||this.useRefreshTokens){let tk=this.getToken(user);if(!tk||tk!==token){resolve(false);return}}resolve(arr)})};getMongoUsersByIds=async(user,userIds=[],basicInfo)=>{let usrs=[];userIds.forEach(u=>{try{usrs.push({_id:toObjectId(u)})}catch{}});let found=[];if(usrs.length>0){let users=this.collections.profile.instance.find({$or:usrs});let arr=await users.toArray();if(arr.length>0){arr.forEach(u=>{if(basicInfo){found.push({username:u.username,firstName:u.firstName,lastName:u.lastName,fullName:u.fullName,pictureUrl:u.pictureUrl,_id:u._id})}else found.push(u)})}}return found};getMongoUsersByRole=async(user,role)=>{let users=this.collections.profile.instance.find({userRoles:{$all:{[role]:true}}});let found=[];let arr=await users.toArray();if(arr.length>0){arr.forEach(u=>{found.push(u)})}return found};getMongoDataByIds=async(user,structIds,ownerId,collection,token)=>{let uid=getStringId(user._id);if(structIds.length>0){let query=[];structIds.forEach(_id=>{let q2={_id:toObjectId(_id)};if(ownerId)q2.ownerId=ownerId;query.push(q2)});let found=[];if(!collection){await Promise.all(Object.keys(this.collections).map(async name=>{let cursor=await this.db.collection(name).find({$or:query});let arr=await cursor.toArray();if(arr.length>0){let passed=true;let checkedAuth="";for(let i3=0;i3<arr.length;i3++){let s=arr[i3];if(!s?.ownerId)passed=true;else if((uid!==s.ownerId||uid===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s,"READ",token);checkedAuth=s.ownerId}if(passed)found.push(s)}}}))}else{let cursor=await this.db.collection(collection).find({$or:query});let arr=await cursor.toArray();if(arr.length>0){let passed=true;let checkedAuth="";arr.forEach(async s=>{if(!s?.ownerId)passed=true;else if((uid!==s.ownerId||uid===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s,"READ",token);checkedAuth=s.ownerId}if(passed)found.push(s)})}}return found}};getMongoData=async(user,collection,ownerId,dict={},limit=0,skip=0,token)=>{if(!ownerId)ownerId=dict?.ownerId;if(!dict)dict={};if(dict._id)dict._id=toObjectId(dict._id);let uid=getStringId(user._id);let structs=[];let passed=true;let checkedAuth="";let cursor;if(!collection&&!ownerId&&!dict)return[];else if(!collection&&ownerId&&Object.keys(dict).length===0)return await this.getAllUserMongoData(user,ownerId);else if((!dict||Object.keys(dict).length===0)&&ownerId&&collection){cursor=this.db.collection(collection).find({ownerId}).sort({$natural:-1}).skip(skip)}else if(collection&&Object.keys(dict).length>0){if(ownerId)dict.ownerId=ownerId;cursor=await this.db.collection(collection).find(dict).sort({$natural:-1}).skip(skip)}if(cursor){if(limit>0)cursor.limit(limit);let arr=await cursor.toArray();if(arr.length>0){for(let i3=0;i3<arr.length;i3++){let s=arr[i3];if(!s?.ownerId)passed=true;else if((uid!==s.ownerId||uid===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s,"READ",token);checkedAuth=s.ownerId}if(passed===true)structs.push(s)}}}else if(!collection&&Object.keys(dict).length>0&&!ownerId){await Promise.all(Object.keys(this.collections).map(async name=>{cursor=await this.db.collection(name).find(dict).sort({$natural:-1}).skip(skip);;if(cursor){if(limit>0)cursor.limit(limit);let arr=await cursor.toArray();if(arr.length>0){for(let i3=0;i3<arr.length;i3++){let s=arr[i3];if(!s?.ownerId)passed=true;else if((uid!==s.ownerId||uid===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s,"READ",token);checkedAuth=s.ownerId}if(passed===true)structs.push(s)}}}}))}if(!passed)return[];return structs};getAllUserMongoData=async(user,ownerId,excluded=[],timeRange,token)=>{let structs=[];let passed=true;let checkedId="";await Promise.all(Object.keys(this.collections).map(async(name,j2)=>{if(passed&&excluded.indexOf(name)<0){let query={ownerId};if(timeRange){if(typeof timeRange[0]==="string")timeRange[0]=genTimestampFromString(timeRange[0]);if(typeof timeRange[1]==="string")timeRange[1]=genTimestampFromString(timeRange[1]);query.timestamp={$gt:timeRange[0],$lt:timeRange[1]}}let cursor=this.db.collection(name).find(query);let arr=await cursor.toArray();let count=arr.length;for(let k2=0;k2<count;k2++){let struct=arr[k2];if(!ownerId)passed=true;else if((getStringId(user._id)!==ownerId||getStringId(user._id)===ownerId&&user.userRoles?.admincontrol)&&checkedId!==ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);checkedId=ownerId}if(passed)structs.push(struct)}}}));if(!passed)return[];return structs};getMongoDataByRefs=async(user,structRefs=[],token)=>{let structs=[];if(structs.length>0){let checkedAuth="";structRefs.forEach(async ref=>{if(ref.structType&&getStringId(ref._id)){let struct=await this.db.collection(ref.structType).findOne({_id:toObjectId(ref._id)});if(struct){let passed=true;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if((getStringId(user._id)!==struct.ownerId||getStringId(user._id)===struct.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==struct.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);checkedAuth=struct.ownerId}if(passed===true){structs.push(struct)}}}})}return structs};getMongoAuthorizations=async(user,ownerId=getStringId(user._id),authId="",token)=>{let auths=[];if(authId.length===0){let cursor=this.collections.authorization.instance.find({ownerId});let arr=await cursor.toArray();if(arr.length>0){arr.forEach(a=>{auths.push(a)})}}else auths.push(await this.collections.authorization.instance.findOne({_id:toObjectId(authId),ownerId}));if(!auths[0]?.ownerId)true;else if(getStringId(user._id)!==auths[0]?.ownerId){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,auths[0],"READ",token);if(!passed)return void 0}return auths};getMongoGroups=async(user,userId=getStringId(user._id),groupId="")=>{let groups=[];if(groupId.length===0){let cursor=this.collections.group.instance.find({users:{$all:[userId]}});let arr=await cursor.toArray();if(arr.length>0){arr.forEach(a=>{groups.push(a)})}}else{try{groups.push(await this.collections.group.instance.findOne({_id:toObjectId(groupId),users:{$all:[userId]}}))}catch{}}return groups};deleteMongoData=async(user,structRefs=[],token)=>{let structs=[];await Promise.all(structRefs.map(async ref=>{try{let _id=toObjectId(ref._id);let struct=await this.db.collection(ref.structType).findOne({_id});if(struct){structs.push(struct);let notifications=await this.collections.notifications.instance.find({parent:{structType:ref.structType,_id:getStringId(ref._id)}});let count=notifications.toArray().length;for(let i3=0;i3<count;i3++){let note=await notifications.next();if(note)structs.push(note)}}}catch{}}));let checkedOwner="";await Promise.all(structs.map(async(struct,i3)=>{let passed=true;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if((struct.ownerId!==getStringId(user._id)||getStringId(user._id)===struct.ownerId&&user.userRoles?.admincontrol)&&struct.ownerId!==checkedOwner){checkedOwner=struct.ownerId;if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token)}if(passed){await this.db.collection(struct.structType?struct.structType:"data").deleteOne({_id:toObjectId(struct._id)});if(struct.users){Object.keys(struct.users).forEach(uid=>{if(uid!==getStringId(user._id)&&uid!==struct.ownerId&&this.users[uid])this.users[uid]?.sendAll({route:"structDeleted",args:{_id:getStringId(struct._id),structType:struct.structType}})})}if(struct.ownerId!==user._id&&this.users[struct.ownerId]){this.users[struct.ownerId]?.sendAll({route:"structDeleted",args:{_id:getStringId(struct._id),structType:struct.structType}})}}}));return true};deleteMongoUser=async(user,userId,deleteData,token)=>{if(getStringId(user._id)!==userId||getStringId(user._id)===userId&&user.userRoles?.admincontrol){let u=await this.collections.profile.instance.findOne({id:userId});let passed=!this.useAuths;if(!u?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,u,"WRITE",token);if(!passed)return false}await this.collections.profile.instance.deleteOne({id:userId});if(deleteData){for(const key in this.collections){this.collections[key].instance.deleteMany({ownerId:userId});this.collections[key].instance.updateMany({users:{[userId]:true}},{$unset:{[`users.${userId}`]:""}})}}if(getStringId(user._id)!==userId&&this.users[userId])this.users[userId]?.sendAll({route:"structDeleted",args:{_id:userId,structType:"profile"}});return true};deleteMongoGroup=async(user,groupId,token)=>{let s=await this.collections.group.instance.findOne({_id:toObjectId(groupId)});if(s){if(!s?.ownerId)true;else if(getStringId(user._id)!==s.ownerId||getStringId(user._id)===s.ownerId&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,s,"WRITE",token);if(!passed)return false}if(s.users){Object.keys(s.users).forEach(u=>{this.users[u]?.sendAll({route:"structDeleted",args:{_id:getStringId(s._id),structType:s.structType}})})}await this.collections.group.instance.deleteOne({_id:toObjectId(groupId)});return true}else return false};deleteMongoAuthorization=async(user,authId,token)=>{let s=await this.collections.authorization.instance.findOne({_id:toObjectId(authId)});let uid=getStringId(user._id);if(s){if(uid!==s.ownerId||uid===s.ownerId&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(!s?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,s,"WRITE",token);if(!passed)return false}if(s.associatedAuthId){if(this.debug)console.log(s);await this.collections.authorization.instance.deleteOne({_id:toObjectId(s.associatedAuthId)});if(s.authorizerId!==uid)this.users[s.authorizerId]?.sendAll({route:"structDeleted",args:{_id:getStringId(s.associatedAuthId),structType:s.structType}});else if(s.authorizedId!==uid)this.users[s.authorizedId]?.sendAll({route:"structDeleted",args:{_id:getStringId(s.associatedAuthId),structType:s.structType}})}await this.collections.authorization.instance.deleteOne({_id:toObjectId(authId)});if(s.authorizerId===uid)this.users[s.authorizerId]?.sendAll({route:"structDeleted",args:{_id:getStringId(s._id),structType:s.structType}});else if(s.authorizedId===uid)this.users[s.authorizedId]?.sendAll({route:"structDeleted",args:{_id:getStringId(s._id),structType:s.structType}});return true}else return false};setAuthorization=async(user,authStruct,token)=>{let u1,u2;let mmode=this.mode.includes("mongo");if(mmode){u1=(await this.getMongoUser(user,authStruct.authorizedId,false)).user;u2=(await this.getMongoUser(user,authStruct.authorizerId,false)).user}else{u1=this.getLocalData("profile",{"_id":authStruct.authorizedId})?.[0];u2=this.getLocalData("profile",{"_id":authStruct.authorizerId})?.[0]}if(!u1||!u2)return false;if(authStruct.authorizedId!==getStringId(u1._id))authStruct.authorizedId=getStringId(u1._id);if(authStruct.authorizerId!==getStringId(u2._id))authStruct.authorizerId=getStringId(u2._id);if(!authStruct.authorizedName){if(u1.name)authStruct.authorizedName=u1.name;else if(u1.username)authStruct.authorizedName=u1.username;else if(u1.email)authStruct.authorizedName=u1.email}if(!authStruct.authorizerName){if(u1.name)authStruct.authorizedName=u1.name;else if(u2.username)authStruct.authorizerName=u2.username;else if(u2.email)authStruct.authorizerName=u2.email}if(!authStruct?.ownerId)true;else if((getStringId(user._id)!==authStruct.ownerId||getStringId(user._id)===authStruct.ownerId&&user.userRoles?.admincontrol)&&(getStringId(user._id)!==authStruct.authorizedId&&getStringId(user._id)!==authStruct.authorizerId)){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,authStruct,"WRITE",token);if(!passed)return false}let auths=[];if(mmode){let s=await this.collections.authorization.instance.find({$and:[{authorizedId:authStruct.authorizedId},{authorizerId:authStruct.authorizerId}]});let arr=await s.toArray();if(arr.length>0){arr.forEach(d=>auths.push(d))}}else{let s=this.getLocalData("authorization",{authorizedId:authStruct.authorizedId});if(Array.isArray(s)){s.forEach(d=>{if(d.authorizerId===authStruct.authorizerId)auths.push(d)})}}let otherAuthset;if(Array.isArray(auths)){for(let i3=0;i3<auths.length;i3++){const auth=auths[i3];if(auth.ownerId===getStringId(user._id)){}else{if(authStruct.authorizerId===getStringId(user._id)){auth.authorizations=authStruct.authorizations;auth.structs=authStruct.structs;auth.excluded=authStruct.excluded;auth.expires=authStruct.expires;auth.status="OKAY";authStruct.status="OKAY"}else{authStruct.authorizations=auth.authorizations;authStruct.structs=auth.structs;authStruct.excluded=auth.excluded;authStruct.expires=auth.expires;auth.status="OKAY";authStruct.status="OKAY"}authStruct.associatedAuthId=getStringId(auth._id);auth.associatedAuthId=getStringId(authStruct._id);otherAuthset=auth;let copy2=JSON.parse(JSON.stringify(auth));if(mmode){delete copy2._id;await this.collections.authorization.instance.updateOne({$and:[{authorizedId:authStruct.authorizedId},{authorizerId:authStruct.authorizerId},{ownerId:auth.ownerId}]},{$set:copy2},{upsert:true})}else{this.setLocalData(copy2)}}}}let copy=JSON.parse(JSON.stringify(authStruct));if(mmode){delete copy._id;await this.collections.authorization.instance.updateOne({$and:[{authorizedId:authStruct.authorizedId},{authorizerId:authStruct.authorizerId},{ownerId:authStruct.ownerId}]},{$set:copy},{upsert:true})}else{this.setLocalData(copy)}if(getStringId(authStruct._id).includes("defaultId")&&mmode){let replacedAuth=await this.collections.authorization.instance.findOne(copy);if(replacedAuth){authStruct._id=getStringId(replacedAuth._id);if(otherAuthset){let otherAuth=await this.collections.authorization.instance.findOne({$and:[{authorizedId:otherAuthset.authorizedId},{authorizerId:otherAuthset.authorizerId},{ownerId:otherAuthset.ownerId}]});if(otherAuth){otherAuth.associatedAuthId=getStringId(authStruct._id);let copy2=JSON.parse(JSON.stringify(otherAuth));delete copy2._id;await this.collections.authorization.instance.updateOne({$and:[{authorizedId:otherAuth.authorizedId},{authorizerId:otherAuth.authorizerId},{ownerId:otherAuth.ownerId}]},{$set:copy2},{upsert:true});this.checkToNotify(user,[otherAuth])}}}}return authStruct};checkAuthorization=async(user,struct,request="READ",token)=>{if(typeof user==="string"){if(this.users[user])user=this.users[user];else user={_id:user}}if(!user||!struct)return false;if(!struct.ownerId)return true;if(typeof user==="object"){if(struct.ownerId===getStringId(user._id)){if(user.userRoles?.["admincontrol"]){}return true}}if(this.useAccessTokens){if(!this.accessTokens.get(user._id)||this.accessTokens.get(user._id)!==token){return false}}else if(this.useRefreshTokens){if(!this.refreshTokens.get(user._id)||this.refreshTokens.get(user._id)!==token){return false}}let auth1,auth2;if(this.mode.includes("mongo")){auth1=await this.collections.authorization.instance.findOne({$or:[{authorizedId:getStringId(user._id),authorizerId:struct.ownerId,ownerId:getStringId(user._id)},{authorizedId:struct.ownerId,authorizerId:getStringId(user._id),ownerId:getStringId(user._id)}]});if(!auth1)return false;auth2=await this.collections.authorization.instance.findOne({$or:[{authorizedId:getStringId(user._id),authorizerId:struct.ownerId,ownerId:getStringId(struct.ownerId)},{authorizedId:struct.ownerId,authorizerId:getStringId(user._id),ownerId:getStringId(struct.ownerId)}]})}else{auth1=this.getLocalData("authorization",{ownerId:getStringId(user._id)}).find(o=>{if(o.authorizedId===getStringId(user._id)&&o.authorizerId===struct.ownerId)return true});auth2=this.getLocalData("authorization",{ownerId:struct.ownerId}).find(o=>{if(o.authorizedId===getStringId(user._id)&&o.authorizerId===struct.ownerId)return true})}if(!auth1||!auth2){return false}let passed=false;if(auth1.status==="OKAY"&&auth2.status==="OKAY"){if(struct.structType==="group"){if(auth1.authorizations[struct.name+"_admin"]&&auth2.authorizations[struct.name+"_admin"])passed=true}else if(auth1.authorizations["peer"]&&auth2.authorizations["peer"])passed=true;else if(auth1.authorizations["admincontrol"]&&auth2.authorizations["admincontrol"])passed=true;else if(auth1.structIds[getStringId(struct._id)]&&auth2.structIds[getStringId(struct._id)])passed=true;else if(auth1.excluded[struct.structType]&&struct.ownerId===getStringId(user._id)&&request==="WRITE")passed=false}return passed};wipeDB=async()=>{await Promise.all(Object.values(this.collections).map(c=>{try{c.instance.remove({})}catch(err){}}));return true};overwriteLocalData=structs=>{if(Array.isArray(structs)){structs.forEach(struct=>{let localdat=this.getLocalData(struct.structType,{"ownerId":struct.ownerId,"_id":getStringId(struct._id)});if(!localdat||localdat?.length===0){this.setLocalData(struct)}else Object.assign(localdat,struct)})}else{let localdat=this.getLocalData(structs.structType,{"ownerId":structs.ownerId,"_id":getStringId(structs._id)});if(!localdat||localdat?.length===0){this.setLocalData(structs)}else Object.assign(localdat,structs)}};setLocalData=structs=>{let setInCollection=s=>{let type=s.structType;let collection=this.collections[type]?.reference;if(!collection){collection={};if(!this.collections[type])this.collections[type]={};this.collections[type].reference=collection}collection[getStringId(s._id)]=s};if(Array.isArray(structs)){structs.forEach(s=>{setInCollection(s)})}else setInCollection(structs)};getLocalData=(collection,query)=>{let ownerId,key,value;if(typeof query==="object"){ownerId=query.ownerId;const keys=Object.keys(query).filter(k2=>k2!="ownerId");key=keys[0];value=query[key]}else value=query;if(!collection&&!ownerId&&!key&&!value)return[];let result=[];if(!collection&&(ownerId||key)){Object.values(this.collections).forEach(c=>{c=c.reference;if((key==="_id"||key==="id")&&value){let found=c[value];if(found)result.push(found)}else{Object.values(c).forEach(struct=>{if(key&&value){if(struct[key]===value&&struct.ownerId===ownerId){result.push(struct)}}else if(struct.ownerId===ownerId){result.push(struct)}})}});return result}else{let c=this.collections[collection]?.reference;if(!c)return result;if(!key&&!ownerId){Object.values(c).forEach(struct=>{result.push(struct)});return result}if((key==="_id"||key==="id")&&value)return getStringId(c[value]);else{Object.keys(c).forEach(k2=>{const struct=c[k2];if(key&&value&&!ownerId){if(struct[key]===value)result.push(struct)}else if(ownerId&&!key){if(struct.ownerId===ownerId)result.push(struct)}else if(ownerId&&key&&value){if(struct.ownerId===ownerId&&struct[key]){if(struct[key]===value)result.push(struct)}}})}}return result};deleteLocalData=struct=>{if(!struct)throw new Error("Struct not supplied");if(!struct.structType||!struct._id)return false;if(this.collections[struct.structType])delete this.collections[struct.structType].reference[struct._id];return true}};var shallowqueryDummy=DataStructures_exports.ProfileStruct();for(const key in shallowqueryDummy){if(key==="username"||key==="lastName"||key==="firstName"||key==="name"||key==="_id"||key==="pictureUrl")shallowqueryDummy[key]=1;else delete shallowqueryDummy[key]}export{AuthorizationStruct,ChatroomStruct,CoherenceMap,CoherenceStruct,CommentStruct,DataStructures_exports as DS,Data,DataStruct,DataTablet,DateStruct,ECGStruct,EDAStruct,EEGCoordinates,EEGStruct,EMGStruct,EventStruct,EyeTrackerStruct,FNIRSStruct,FrequencyBandsStruct,GroupStruct,HRVStruct,IMUStruct,NotificationStruct,PPGStruct,ProfileStruct,ScheduleStruct,Struct,StructBackend,StructFrontend,defaultCollections,defaultSpecifiers,eegCoordinates,genTimeSpecifiers,genTimestampFromString,getStringId,pseudoObjectId,randomId,setCoordinate,structRegistry,toObjectId};
